"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   Expanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Expanding),\n/* harmony export */   Filters: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Filters),\n/* harmony export */   Grouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Grouping),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   Ordering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Ordering),\n/* harmony export */   Pagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pagination),\n/* harmony export */   Pinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   Sorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Sorting),\n/* harmony export */   Visibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Visibility),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n * react-table\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4QjtBQUNvQjtBQUNkO0FBRXJDLEVBQUU7QUFDRjs7Q0FFQyxHQUNELFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUM3QixPQUFPLENBQUNELE9BQU8sT0FBT0UsaUJBQWlCRixRQUFRLFdBQVcsR0FBRUgsZ0RBQW1CLENBQUNHLE1BQU1DLFNBQVNEO0FBQ2pHO0FBQ0EsU0FBU0UsaUJBQWlCRSxTQUFTO0lBQ2pDLE9BQU9DLGlCQUFpQkQsY0FBYyxPQUFPQSxjQUFjLGNBQWNFLGtCQUFrQkY7QUFDN0Y7QUFDQSxTQUFTQyxpQkFBaUJELFNBQVM7SUFDakMsT0FBTyxPQUFPQSxjQUFjLGNBQWMsQ0FBQztRQUN6QyxNQUFNRyxRQUFRQyxPQUFPQyxjQUFjLENBQUNMO1FBQ3BDLE9BQU9HLE1BQU1HLFNBQVMsSUFBSUgsTUFBTUcsU0FBUyxDQUFDUixnQkFBZ0I7SUFDNUQ7QUFDRjtBQUNBLFNBQVNJLGtCQUFrQkYsU0FBUztJQUNsQyxPQUFPLE9BQU9BLGNBQWMsWUFBWSxPQUFPQSxVQUFVTyxRQUFRLEtBQUssWUFBWTtRQUFDO1FBQWM7S0FBb0IsQ0FBQ0MsUUFBUSxDQUFDUixVQUFVTyxRQUFRLENBQUNFLFdBQVc7QUFDL0o7QUFDQSxTQUFTQyxjQUFjQyxPQUFPO0lBQzVCLHFEQUFxRDtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEJDLE9BQU8sQ0FBQztRQUNSLGNBQWM7UUFDZEMsZUFBZSxLQUFPO1FBQ3RCLE9BQU87UUFDUEMscUJBQXFCO1FBQ3JCLEdBQUdKLE9BQU87SUFDWjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNLENBQUNLLFNBQVMsR0FBR3ZCLDJDQUFjLENBQUMsSUFBTztZQUN2Q3lCLFNBQVN4QixpRUFBV0EsQ0FBQ2tCO1FBQ3ZCO0lBRUEsc0VBQXNFO0lBQ3RFLE1BQU0sQ0FBQ0MsT0FBT00sU0FBUyxHQUFHMUIsMkNBQWMsQ0FBQyxJQUFNdUIsU0FBU0UsT0FBTyxDQUFDRSxZQUFZO0lBRTVFLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcERKLFNBQVNFLE9BQU8sQ0FBQ0csVUFBVSxDQUFDQyxDQUFBQSxPQUFTO1lBQ25DLEdBQUdBLElBQUk7WUFDUCxHQUFHWCxPQUFPO1lBQ1ZFLE9BQU87Z0JBQ0wsR0FBR0EsS0FBSztnQkFDUixHQUFHRixRQUFRRSxLQUFLO1lBQ2xCO1lBQ0EsMEVBQTBFO1lBQzFFLFNBQVM7WUFDVEMsZUFBZVMsQ0FBQUE7Z0JBQ2JKLFNBQVNJO2dCQUNUWixRQUFRRyxhQUFhLElBQUksUUFBUUgsUUFBUUcsYUFBYSxDQUFDUztZQUN6RDtRQUNGO0lBQ0EsT0FBT1AsU0FBU0UsT0FBTztBQUN6QjtBQUVxQyxDQUNyQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pbl9wYW5lbC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdGFibGUvYnVpbGQvbGliL2luZGV4Lm1qcz9hMTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3QtdGFibGVcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVRhYmxlIH0gZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnO1xuXG4vL1xuLyoqXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxuICovXG5mdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiB1c2VSZWFjdFRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICAvLyBEdW1teSBzdGF0ZVxuICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIG5vb3BcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgYW5kIHN0b3JlIGl0IGluIHN0YXRlXG4gIGNvbnN0IFt0YWJsZVJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcbiAgfSkpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcbiAgLy8gdG8gb25seSBjb250cm9sIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZSBpZiBkZXNpcmVkLlxuICB0YWJsZVJlZi5jdXJyZW50LnNldE9wdGlvbnMocHJldiA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5vcHRpb25zLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XG4gICAgICBvcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0YWJsZVJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBmbGV4UmVuZGVyLCB1c2VSZWFjdFRhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVUYWJsZSIsImZsZXhSZW5kZXIiLCJDb21wIiwicHJvcHMiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJ1c2VSZWFjdFRhYmxlIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsInN0YXRlIiwib25TdGF0ZUNoYW5nZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJ0YWJsZVJlZiIsInVzZVN0YXRlIiwiY3VycmVudCIsInNldFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic2V0T3B0aW9ucyIsInByZXYiLCJ1cGRhdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   Expanding: () => (/* binding */ Expanding),\n/* harmony export */   Filters: () => (/* binding */ Filters),\n/* harmony export */   Grouping: () => (/* binding */ Grouping),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Ordering: () => (/* binding */ Ordering),\n/* harmony export */   Pagination: () => (/* binding */ Pagination),\n/* harmony export */   Pinning: () => (/* binding */ Pinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   Sorting: () => (/* binding */ Sorting),\n/* harmony export */   Visibility: () => (/* binding */ Visibility),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ // Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return ()=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            }\n        }),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        })\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to uknown, because we know more than the compiler here.\n    return column;\n}\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, {\n            key:  true && \"getHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugHeaders;\n            }\n        });\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, {\n            key:  true && \"getCenterHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, {\n            key:  true && \"getLeftHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugHeaders;\n            }\n        });\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, {\n            key:  true && \"getRightHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugHeaders;\n            }\n        });\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getLeftFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getCenterFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA7;\n                return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getRightFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugHeaders;\n            }\n        });\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA9;\n                return (_table$options$debugA9 = table.options.debugAll) != null ? _table$options$debugA9 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getLeftFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA10;\n                return (_table$options$debugA10 = table.options.debugAll) != null ? _table$options$debugA10 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getCenterFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA11;\n                return (_table$options$debugA11 = table.options.debugAll) != null ? _table$options$debugA11 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getRightFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA12;\n                return (_table$options$debugA12 = table.options.debugAll) != null ? _table$options$debugA12 : table.options.debugHeaders;\n            }\n        });\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, {\n            key:  true && \"getCenterLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA13;\n                return (_table$options$debugA13 = table.options.debugAll) != null ? _table$options$debugA13 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, {\n            key:  true && \"getLeftLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA14;\n                return (_table$options$debugA14 = table.options.debugAll) != null ? _table$options$debugA14 : table.options.debugHeaders;\n            }\n        });\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, {\n            key:  true && \"getRightLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA15;\n                return (_table$options$debugA15 = table.options.debugAll) != null ? _table$options$debugA15 : table.options.debugHeaders;\n            }\n        });\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, {\n            key:  true && \"getLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA16;\n                return (_table$options$debugA16 = table.options.debugAll) != null ? _table$options$debugA16 : table.options.debugHeaders;\n            }\n        });\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = (position)=>{\n            const columns = !position ? table.getVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n            const index = columns.findIndex((d)=>d.id === column.id);\n            if (index > 0) {\n                const prevSiblingColumn = columns[index - 1];\n                return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n            }\n            return 0;\n        };\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = ()=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        document.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        document.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        document.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        document.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    document.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    document.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    document.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    document.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst Expanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst Filters = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            globalFilter: undefined,\n            // filtersProgress: 1,\n            // facetProgress: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100,\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;\n            return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousfilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousfilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    // () => [column.getFacetedRowModel()],\n    // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n    },\n    createRow: (row, table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter3, _table$options$filter4;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];\n        };\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst Grouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _ref, _ref2, _ref3, _column$columnDef$ena;\n            return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst Ordering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, {\n            key:  true && \"getOrderColumnsFn\"\n        });\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst Pagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, {\n            key:  true && \"getPageOptions\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);\n        };\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst Pinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table),\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3)=>{\n                let { id } = _ref3;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref4;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _table$_getPinnedRows, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, {\n            key:  true && \"row.getCenterVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                , \n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getLeftVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getRightVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getLeftLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        });\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getRightLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        });\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, {\n            key:  true && \"getCenterLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugColumns;\n            }\n        });\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState2;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio2;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);\n        };\n        table._getPinnedRows = (position)=>memo(()=>[\n                    table.getRowModel().rows,\n                    table.getState().rowPinning[position]\n                ], (visibleRows, pinnedRowIds)=>{\n                var _table$options$keepPi;\n                const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n                //account for expanded parent rows, but not pagination or filtering\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                    const row = table.getRow(rowId, true);\n                    return row.getIsAllParentsExpanded() ? row : null;\n                }) : //else get only visible rows that are pinned\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n                return rows.filter(Boolean).map((d)=>({\n                        ...d,\n                        position\n                    }));\n            }, {\n                key:  true && `row.get${position === \"top\" ? \"Top\" : \"Bottom\"}Rows`,\n                debug: ()=>{\n                    var _table$options$debugA7;\n                    return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugRows;\n                }\n            })();\n        table.getTopRows = ()=>table._getPinnedRows(\"top\");\n        table.getBottomRows = ()=>table._getPinnedRows(\"bottom\");\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, {\n            key:  true && \"row.getCenterRows\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugRows;\n            }\n        });\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  true && \"getSelectedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugTable;\n            }\n        });\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugTable;\n            }\n        });\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst Sorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\n//\nconst Visibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], {\n            key:  true && \"row.getVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, {\n                key,\n                debug: ()=>{\n                    var _table$options$debugA3;\n                    return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n                }\n            });\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst features = [\n    Headers,\n    Visibility,\n    Ordering,\n    Pinning,\n    Filters,\n    Sorting,\n    Grouping,\n    Expanding,\n    Pagination,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$initialState;\n    if (options.debugAll || options.debugTable) {\n        console.info(\"Creating Table Instance...\");\n    }\n    let table = {\n        _features: features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features: features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        getRow: (id, searchAll)=>{\n            const row = (searchAll ? table.getCoreRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                if (true) {\n                    throw new Error(`getRow expected an ID, but got ${id}`);\n                }\n                throw new Error();\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, {\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            },\n            key:  true && \"getDefaultColumnDef\"\n        }),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, {\n            key:  true && \"getAllColumns\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        }),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, {\n            key:  true && \"getAllFlatColumns\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n            }\n        }),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, {\n            key:  true && \"getAllFlatColumnsById\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        }),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, {\n            key:  true && \"getAllLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        }),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), {\n            key:  true && \"cell.getContext\",\n            debug: ()=>table.options.debugAll\n        })\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, {\n            key:  true && \"row.getAllCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        }),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        })\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, {\n            key:  true && \"getRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = columnFilters.map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFilteredRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFacetedRowModel_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, {\n            key:  true && \"getFacetedUniqueValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, {\n            key:  true && \"getFacetedMinMaxValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (columnInfo.sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, {\n            key:  true && \"getSortedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, {\n            key:  true && \"getGroupedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._queue(()=>{\n                    table._autoResetExpanded();\n                    table._autoResetPageIndex();\n                });\n            }\n        });\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, {\n            key:  true && \"getExpandedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, {\n            key:  true && \"getPaginationRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDRCx3QkFBd0I7QUFFeEIscURBQXFEO0FBRXJELEdBQUc7QUFFSCxTQUFTQSxpQkFBaUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxPQUFPLE9BQU9ELFlBQVksYUFBYUEsUUFBUUMsU0FBU0Q7QUFDMUQ7QUFDQSxTQUFTRTtBQUNQLEVBQUU7QUFDSjtBQUNBLFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxRQUFRO0lBQ3JDLE9BQU9MLENBQUFBO1FBQ0xLLFNBQVNDLFFBQVEsQ0FBQ0MsQ0FBQUE7WUFDaEIsT0FBTztnQkFDTCxHQUFHQSxHQUFHO2dCQUNOLENBQUNILElBQUksRUFBRUwsaUJBQWlCQyxTQUFTTyxHQUFHLENBQUNILElBQUk7WUFDM0M7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTSSxXQUFXQyxDQUFDO0lBQ25CLE9BQU9BLGFBQWFDO0FBQ3RCO0FBQ0EsU0FBU0MsY0FBY0YsQ0FBQztJQUN0QixPQUFPRyxNQUFNQyxPQUFPLENBQUNKLE1BQU1BLEVBQUVLLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBTyxPQUFPQSxRQUFRO0FBQzNEO0FBQ0EsU0FBU0MsVUFBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLE1BQU1DLE9BQU8sRUFBRTtJQUNmLE1BQU1DLFVBQVVDLENBQUFBO1FBQ2RBLE9BQU9DLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDYkosS0FBS0ssSUFBSSxDQUFDRDtZQUNWLE1BQU1FLFdBQVdQLFlBQVlLO1lBQzdCLElBQUlFLFlBQVksUUFBUUEsU0FBU0MsTUFBTSxFQUFFO2dCQUN2Q04sUUFBUUs7WUFDVjtRQUNGO0lBQ0Y7SUFDQUwsUUFBUUg7SUFDUixPQUFPRTtBQUNUO0FBQ0EsU0FBU1EsS0FB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SSxDQUFDcGpCLE9BQU8sQ0FBQzY1QjtZQUMvQixPQUFPRztRQUNULEdBQUc7WUFDRGw3QixLQUFLeUUsS0FBeUIsSUFBaUI7WUFDL0MzQyxPQUFPO2dCQUNMLElBQUltRDtnQkFDSixPQUFPLENBQUNBLHdCQUF3QjNCLE1BQU00QixPQUFPLENBQUNDLFFBQVEsS0FBSyxPQUFPRix3QkFBd0IzQixNQUFNNEIsT0FBTyxDQUFDMmUsVUFBVTtZQUNwSDtRQUNGO0FBQ0Y7QUFFc3JCLENBQ3RyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pbl9wYW5lbC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdGFibGUtY29yZS9idWlsZC9saWIvaW5kZXgubWpzPzU1NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0YWJsZS1jb3JlXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vLyBJcyB0aGlzIHR5cGUgYSB0dXBsZT9cblxuLy8gSWYgdGhpcyB0eXBlIGlzIGEgdHVwbGUsIHdoYXQgaW5kaWNlcyBhcmUgYWxsb3dlZD9cblxuLy8vXG5cbmZ1bmN0aW9uIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgaW5wdXQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1cGRhdGVyID09PSAnZnVuY3Rpb24nID8gdXBkYXRlcihpbnB1dCkgOiB1cGRhdGVyO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy9cbn1cbmZ1bmN0aW9uIG1ha2VTdGF0ZVVwZGF0ZXIoa2V5LCBpbnN0YW5jZSkge1xuICByZXR1cm4gdXBkYXRlciA9PiB7XG4gICAgaW5zdGFuY2Uuc2V0U3RhdGUob2xkID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgW2tleV06IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkW2tleV0pXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihkKSB7XG4gIHJldHVybiBkIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5mdW5jdGlvbiBpc051bWJlckFycmF5KGQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZCkgJiYgZC5ldmVyeSh2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpO1xufVxuZnVuY3Rpb24gZmxhdHRlbkJ5KGFyciwgZ2V0Q2hpbGRyZW4pIHtcbiAgY29uc3QgZmxhdCA9IFtdO1xuICBjb25zdCByZWN1cnNlID0gc3ViQXJyID0+IHtcbiAgICBzdWJBcnIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGZsYXQucHVzaChpdGVtKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaXRlbSk7XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVjdXJzZShjaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJlY3Vyc2UoYXJyKTtcbiAgcmV0dXJuIGZsYXQ7XG59XG5mdW5jdGlvbiBtZW1vKGdldERlcHMsIGZuLCBvcHRzKSB7XG4gIGxldCBkZXBzID0gW107XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKCk7XG4gICAgY29uc3QgZGVwc0NoYW5nZWQgPSBuZXdEZXBzLmxlbmd0aCAhPT0gZGVwcy5sZW5ndGggfHwgbmV3RGVwcy5zb21lKChkZXAsIGluZGV4KSA9PiBkZXBzW2luZGV4XSAhPT0gZGVwKTtcbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkZXBzID0gbmV3RGVwcztcbiAgICBsZXQgcmVzdWx0VGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZykgcmVzdWx0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmVzdWx0ID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgb3B0cyA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlKHJlc3VsdCk7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHtcbiAgICAgIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5kZWJ1ZygpKSB7XG4gICAgICAgIGNvbnN0IGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcbiAgICAgICAgY29uc3QgcGFkID0gKHN0ciwgbnVtKSA9PiB7XG4gICAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICAgIHN0ciA9ICcgJyArIHN0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5pbmZvKGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsIGBcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGNvbG9yOiBoc2woJHtNYXRoLm1heCgwLCBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApKX1kZWcgMTAwJSAzMSUpO2AsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uKHRhYmxlLCBjb2x1bW5EZWYsIGRlcHRoLCBwYXJlbnQpIHtcbiAgdmFyIF9yZWYsIF9yZXNvbHZlZENvbHVtbkRlZiRpZDtcbiAgY29uc3QgZGVmYXVsdENvbHVtbiA9IHRhYmxlLl9nZXREZWZhdWx0Q29sdW1uRGVmKCk7XG4gIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0ge1xuICAgIC4uLmRlZmF1bHRDb2x1bW4sXG4gICAgLi4uY29sdW1uRGVmXG4gIH07XG4gIGNvbnN0IGFjY2Vzc29yS2V5ID0gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gIGxldCBpZCA9IChfcmVmID0gKF9yZXNvbHZlZENvbHVtbkRlZiRpZCA9IHJlc29sdmVkQ29sdW1uRGVmLmlkKSAhPSBudWxsID8gX3Jlc29sdmVkQ29sdW1uRGVmJGlkIDogYWNjZXNzb3JLZXkgPyBhY2Nlc3NvcktleS5yZXBsYWNlKCcuJywgJ18nKSA6IHVuZGVmaW5lZCkgIT0gbnVsbCA/IF9yZWYgOiB0eXBlb2YgcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyID09PSAnc3RyaW5nJyA/IHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA6IHVuZGVmaW5lZDtcbiAgbGV0IGFjY2Vzc29yRm47XG4gIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgYWNjZXNzb3JGbiA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm47XG4gIH0gZWxzZSBpZiAoYWNjZXNzb3JLZXkpIHtcbiAgICAvLyBTdXBwb3J0IGRlZXAgYWNjZXNzb3Iga2V5c1xuICAgIGlmIChhY2Nlc3NvcktleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBhY2Nlc3NvckZuID0gb3JpZ2luYWxSb3cgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxSb3c7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjY2Vzc29yS2V5LnNwbGl0KCcuJykpIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDtcbiAgICAgICAgICByZXN1bHQgPSAoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHRba2V5XTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIiR7a2V5fVwiIGluIGRlZXBseSBuZXN0ZWQga2V5IFwiJHthY2Nlc3NvcktleX1cIiByZXR1cm5lZCB1bmRlZmluZWQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nlc3NvckZuID0gb3JpZ2luYWxSb3cgPT4gb3JpZ2luYWxSb3dbcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXldO1xuICAgIH1cbiAgfVxuICBpZiAoIWlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuID8gYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGFuIGFjY2Vzc29yRm5gIDogYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGEgbm9uLXN0cmluZyBoZWFkZXJgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgbGV0IGNvbHVtbiA9IHtcbiAgICBpZDogYCR7U3RyaW5nKGlkKX1gLFxuICAgIGFjY2Vzc29yRm4sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgZGVwdGgsXG4gICAgY29sdW1uRGVmOiByZXNvbHZlZENvbHVtbkRlZixcbiAgICBjb2x1bW5zOiBbXSxcbiAgICBnZXRGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdHJ1ZV0sICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICByZXR1cm4gW2NvbHVtbiwgLi4uKChfY29sdW1uJGNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW4kY29sdW1ucy5mbGF0TWFwKGQgPT4gZC5nZXRGbGF0Q29sdW1ucygpKSldO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAnY29sdW1uLmdldEZsYXRDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGdldExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIG9yZGVyQ29sdW1ucyA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zMjtcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zMiA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1uczIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NvbHVtbl07XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdjb2x1bW4uZ2V0TGVhZkNvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSlcbiAgfTtcbiAgZm9yIChjb25zdCBmZWF0dXJlIG9mIHRhYmxlLl9mZWF0dXJlcykge1xuICAgIGZlYXR1cmUuY3JlYXRlQ29sdW1uID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDb2x1bW4oY29sdW1uLCB0YWJsZSk7XG4gIH1cblxuICAvLyBZZXMsIHdlIGhhdmUgdG8gY29udmVydCB0YWJsZSB0byB1a25vd24sIGJlY2F1c2Ugd2Uga25vdyBtb3JlIHRoYW4gdGhlIGNvbXBpbGVyIGhlcmUuXG4gIHJldHVybiBjb2x1bW47XG59XG5cbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRpZDtcbiAgY29uc3QgaWQgPSAoX29wdGlvbnMkaWQgPSBvcHRpb25zLmlkKSAhPSBudWxsID8gX29wdGlvbnMkaWQgOiBjb2x1bW4uaWQ7XG4gIGxldCBoZWFkZXIgPSB7XG4gICAgaWQsXG4gICAgY29sdW1uLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGlzUGxhY2Vob2xkZXI6ICEhb3B0aW9ucy5pc1BsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVySWQ6IG9wdGlvbnMucGxhY2Vob2xkZXJJZCxcbiAgICBkZXB0aDogb3B0aW9ucy5kZXB0aCxcbiAgICBzdWJIZWFkZXJzOiBbXSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIHJvd1NwYW46IDAsXG4gICAgaGVhZGVyR3JvdXA6IG51bGwsXG4gICAgZ2V0TGVhZkhlYWRlcnM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZIZWFkZXJzID0gW107XG4gICAgICBjb25zdCByZWN1cnNlSGVhZGVyID0gaCA9PiB7XG4gICAgICAgIGlmIChoLnN1YkhlYWRlcnMgJiYgaC5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGguc3ViSGVhZGVycy5tYXAocmVjdXJzZUhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVhZkhlYWRlcnMucHVzaChoKTtcbiAgICAgIH07XG4gICAgICByZWN1cnNlSGVhZGVyKGhlYWRlcik7XG4gICAgICByZXR1cm4gbGVhZkhlYWRlcnM7XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiAoKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgIGNvbHVtblxuICAgIH0pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGZlYXR1cmUuY3JlYXRlSGVhZGVyID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVIZWFkZXIoaGVhZGVyLCB0YWJsZSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyO1xufVxuY29uc3QgSGVhZGVycyA9IHtcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICAvLyBIZWFkZXIgR3JvdXBzXG5cbiAgICB0YWJsZS5nZXRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIsIF9yaWdodCRtYXAkZmlsdGVyO1xuICAgICAgY29uc3QgbGVmdENvbHVtbnMgPSAoX2xlZnQkbWFwJGZpbHRlciA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IHJpZ2h0Q29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlciA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IGNlbnRlckNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIFsuLi5sZWZ0Q29sdW1ucywgLi4uY2VudGVyQ29sdW1ucywgLi4ucmlnaHRDb2x1bW5zXSwgdGFibGUpO1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3VwcztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRIZWFkZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGxlYWZDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiAhKGxlZnQgIT0gbnVsbCAmJiBsZWZ0LmluY2x1ZGVzKGNvbHVtbi5pZCkpICYmICEocmlnaHQgIT0gbnVsbCAmJiByaWdodC5pbmNsdWRlcyhjb2x1bW4uaWQpKSk7XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHRhYmxlLCAnY2VudGVyJyk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Q2VudGVySGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9sZWZ0JG1hcCRmaWx0ZXIyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAnbGVmdCcpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlZnRIZWFkZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX3JpZ2h0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyMiA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ3JpZ2h0Jyk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRIZWFkZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTQ7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGb290ZXIgR3JvdXBzXG5cbiAgICB0YWJsZS5nZXRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZvb3Rlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTUgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdEZvb3Rlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTYgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckZvb3Rlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNztcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTcgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRSaWdodEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSaWdodEZvb3Rlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBODtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTggOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZsYXQgSGVhZGVyc1xuXG4gICAgdGFibGUuZ2V0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZsYXRIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E5O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTkgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBOSA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldExlZnRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdEZsYXRIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMDtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMCA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldENlbnRlckZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCldLCBsZWZ0ID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Lm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckZsYXRIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMSA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSaWdodEZsYXRIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTGVhZiBIZWFkZXJzXG5cbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMgPSBoZWFkZXIuc3ViSGVhZGVycykgIT0gbnVsbCAmJiBfaGVhZGVyJHN1YkhlYWRlcnMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckxlYWZIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMztcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldExlZnRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRGbGF0SGVhZGVycygpXSwgZmxhdEhlYWRlcnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xuICAgICAgICB2YXIgX2hlYWRlciRzdWJIZWFkZXJzMjtcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVyczIgPSBoZWFkZXIuc3ViSGVhZGVycykgIT0gbnVsbCAmJiBfaGVhZGVyJHN1YkhlYWRlcnMyLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0TGVhZkhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTE0O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTE0ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTE0IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRMZWFmSGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTU7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTUgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTUgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCksIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JDAkaGVhZGVycywgX2xlZnQkLCBfY2VudGVyJDAkaGVhZGVycywgX2NlbnRlciQsIF9yaWdodCQwJGhlYWRlcnMsIF9yaWdodCQ7XG4gICAgICByZXR1cm4gWy4uLigoX2xlZnQkMCRoZWFkZXJzID0gKF9sZWZ0JCA9IGxlZnRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGVmdCQuaGVhZGVycykgIT0gbnVsbCA/IF9sZWZ0JDAkaGVhZGVycyA6IFtdKSwgLi4uKChfY2VudGVyJDAkaGVhZGVycyA9IChfY2VudGVyJCA9IGNlbnRlclswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jZW50ZXIkLmhlYWRlcnMpICE9IG51bGwgPyBfY2VudGVyJDAkaGVhZGVycyA6IFtdKSwgLi4uKChfcmlnaHQkMCRoZWFkZXJzID0gKF9yaWdodCQgPSByaWdodFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yaWdodCQuaGVhZGVycykgIT0gbnVsbCA/IF9yaWdodCQwJGhlYWRlcnMgOiBbXSldLm1hcChoZWFkZXIgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmdldExlYWZIZWFkZXJzKCk7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVhZkhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTE2O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTE2ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTE2IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBjb2x1bW5zVG9Hcm91cCwgdGFibGUsIGhlYWRlckZhbWlseSkge1xuICB2YXIgX2hlYWRlckdyb3VwcyQwJGhlYWRlLCBfaGVhZGVyR3JvdXBzJDtcbiAgLy8gRmluZCB0aGUgbWF4IGRlcHRoIG9mIHRoZSBjb2x1bW5zOlxuICAvLyBidWlsZCB0aGUgbGVhZiBjb2x1bW4gcm93XG4gIC8vIGJ1aWxkIGVhY2ggYnVmZmVyIHJvdyBnb2luZyB1cFxuICAvLyAgICBwbGFjZWhvbGRlciBmb3Igbm9uLWV4aXN0ZW50IGxldmVsXG4gIC8vICAgIHJlYWwgY29sdW1uIGZvciBleGlzdGluZyBsZXZlbFxuXG4gIGxldCBtYXhEZXB0aCA9IDA7XG4gIGNvbnN0IGZpbmRNYXhEZXB0aCA9IGZ1bmN0aW9uIChjb2x1bW5zLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDE7XG4gICAgfVxuICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGRlcHRoKTtcbiAgICBjb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSgpKS5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zO1xuICAgICAgaWYgKChfY29sdW1uJGNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmRNYXhEZXB0aChjb2x1bW4uY29sdW1ucywgZGVwdGggKyAxKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfTtcbiAgZmluZE1heERlcHRoKGFsbENvbHVtbnMpO1xuICBsZXQgaGVhZGVyR3JvdXBzID0gW107XG4gIGNvbnN0IGNyZWF0ZUhlYWRlckdyb3VwID0gKGhlYWRlcnNUb0dyb3VwLCBkZXB0aCkgPT4ge1xuICAgIC8vIFRoZSBoZWFkZXIgZ3JvdXAgd2UgYXJlIGNyZWF0aW5nXG4gICAgY29uc3QgaGVhZGVyR3JvdXAgPSB7XG4gICAgICBkZXB0aCxcbiAgICAgIGlkOiBbaGVhZGVyRmFtaWx5LCBgJHtkZXB0aH1gXS5maWx0ZXIoQm9vbGVhbikuam9pbignXycpLFxuICAgICAgaGVhZGVyczogW11cbiAgICB9O1xuXG4gICAgLy8gVGhlIHBhcmVudCBjb2x1bW5zIHdlJ3JlIGdvaW5nIHRvIHNjYW4gbmV4dFxuICAgIGNvbnN0IHBlbmRpbmdQYXJlbnRIZWFkZXJzID0gW107XG5cbiAgICAvLyBTY2FuIGVhY2ggY29sdW1uIGZvciBwYXJlbnRzXG4gICAgaGVhZGVyc1RvR3JvdXAuZm9yRWFjaChoZWFkZXJUb0dyb3VwID0+IHtcbiAgICAgIC8vIFdoYXQgaXMgdGhlIGxhdGVzdCAobGFzdCkgcGFyZW50IGNvbHVtbj9cblxuICAgICAgY29uc3QgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciA9IFsuLi5wZW5kaW5nUGFyZW50SGVhZGVyc10ucmV2ZXJzZSgpWzBdO1xuICAgICAgY29uc3QgaXNMZWFmSGVhZGVyID0gaGVhZGVyVG9Hcm91cC5jb2x1bW4uZGVwdGggPT09IGhlYWRlckdyb3VwLmRlcHRoO1xuICAgICAgbGV0IGNvbHVtbjtcbiAgICAgIGxldCBpc1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gICAgICBpZiAoaXNMZWFmSGVhZGVyICYmIGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudCkge1xuICAgICAgICAvLyBUaGUgcGFyZW50IGhlYWRlciBpcyBuZXdcbiAgICAgICAgY29sdW1uID0gaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgcmVwZWF0ZWRcbiAgICAgICAgY29sdW1uID0gaGVhZGVyVG9Hcm91cC5jb2x1bW47XG4gICAgICAgIGlzUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgJiYgKGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIuY29sdW1uKSA9PT0gY29sdW1uKSB7XG4gICAgICAgIC8vIFRoaXMgY29sdW1uIGlzIHJlcGVhdGVkLiBBZGQgaXQgYXMgYSBzdWIgaGVhZGVyIHRvIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBoZWFkZXIuIExldCdzIGNyZWF0ZSBpdFxuICAgICAgICBjb25zdCBoZWFkZXIgPSBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgICAgICAgIGlkOiBbaGVhZGVyRmFtaWx5LCBkZXB0aCwgY29sdW1uLmlkLCBoZWFkZXJUb0dyb3VwID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJUb0dyb3VwLmlkXS5maWx0ZXIoQm9vbGVhbikuam9pbignXycpLFxuICAgICAgICAgIGlzUGxhY2Vob2xkZXIsXG4gICAgICAgICAgcGxhY2Vob2xkZXJJZDogaXNQbGFjZWhvbGRlciA/IGAke3BlbmRpbmdQYXJlbnRIZWFkZXJzLmZpbHRlcihkID0+IGQuY29sdW1uID09PSBjb2x1bW4pLmxlbmd0aH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgIGluZGV4OiBwZW5kaW5nUGFyZW50SGVhZGVycy5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBoZWFkZXJUb0dyb3VwIGFzIGEgc3ViSGVhZGVyIG9mIHRoZSBuZXcgaGVhZGVyXG4gICAgICAgIGhlYWRlci5zdWJIZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IGhlYWRlciB0byB0aGUgcGVuZGluZ1BhcmVudEhlYWRlcnMgdG8gZ2V0IGdyb3VwZWRcbiAgICAgICAgLy8gaW4gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgcGVuZGluZ1BhcmVudEhlYWRlcnMucHVzaChoZWFkZXIpO1xuICAgICAgfVxuICAgICAgaGVhZGVyR3JvdXAuaGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgaGVhZGVyVG9Hcm91cC5oZWFkZXJHcm91cCA9IGhlYWRlckdyb3VwO1xuICAgIH0pO1xuICAgIGhlYWRlckdyb3Vwcy5wdXNoKGhlYWRlckdyb3VwKTtcbiAgICBpZiAoZGVwdGggPiAwKSB7XG4gICAgICBjcmVhdGVIZWFkZXJHcm91cChwZW5kaW5nUGFyZW50SGVhZGVycywgZGVwdGggLSAxKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGJvdHRvbUhlYWRlcnMgPSBjb2x1bW5zVG9Hcm91cC5tYXAoKGNvbHVtbiwgaW5kZXgpID0+IGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCB7XG4gICAgZGVwdGg6IG1heERlcHRoLFxuICAgIGluZGV4XG4gIH0pKTtcbiAgY3JlYXRlSGVhZGVyR3JvdXAoYm90dG9tSGVhZGVycywgbWF4RGVwdGggLSAxKTtcbiAgaGVhZGVyR3JvdXBzLnJldmVyc2UoKTtcblxuICAvLyBoZWFkZXJHcm91cHMgPSBoZWFkZXJHcm91cHMuZmlsdGVyKGhlYWRlckdyb3VwID0+IHtcbiAgLy8gICByZXR1cm4gIWhlYWRlckdyb3VwLmhlYWRlcnMuZXZlcnkoaGVhZGVyID0+IGhlYWRlci5pc1BsYWNlaG9sZGVyKVxuICAvLyB9KVxuXG4gIGNvbnN0IHJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMgPSBoZWFkZXJzID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZEhlYWRlcnMgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4gaGVhZGVyLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkSGVhZGVycy5tYXAoaGVhZGVyID0+IHtcbiAgICAgIGxldCBjb2xTcGFuID0gMDtcbiAgICAgIGxldCByb3dTcGFuID0gMDtcbiAgICAgIGxldCBjaGlsZFJvd1NwYW5zID0gWzBdO1xuICAgICAgaWYgKGhlYWRlci5zdWJIZWFkZXJzICYmIGhlYWRlci5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICBjaGlsZFJvd1NwYW5zID0gW107XG4gICAgICAgIHJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMoaGVhZGVyLnN1YkhlYWRlcnMpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGNvbFNwYW46IGNoaWxkQ29sU3BhbixcbiAgICAgICAgICAgIHJvd1NwYW46IGNoaWxkUm93U3BhblxuICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgIGNvbFNwYW4gKz0gY2hpbGRDb2xTcGFuO1xuICAgICAgICAgIGNoaWxkUm93U3BhbnMucHVzaChjaGlsZFJvd1NwYW4pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbFNwYW4gPSAxO1xuICAgICAgfVxuICAgICAgY29uc3QgbWluQ2hpbGRSb3dTcGFuID0gTWF0aC5taW4oLi4uY2hpbGRSb3dTcGFucyk7XG4gICAgICByb3dTcGFuID0gcm93U3BhbiArIG1pbkNoaWxkUm93U3BhbjtcbiAgICAgIGhlYWRlci5jb2xTcGFuID0gY29sU3BhbjtcbiAgICAgIGhlYWRlci5yb3dTcGFuID0gcm93U3BhbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbFNwYW4sXG4gICAgICAgIHJvd1NwYW5cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIHJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMoKF9oZWFkZXJHcm91cHMkMCRoZWFkZSA9IChfaGVhZGVyR3JvdXBzJCA9IGhlYWRlckdyb3Vwc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkZXJHcm91cHMkLmhlYWRlcnMpICE9IG51bGwgPyBfaGVhZGVyR3JvdXBzJDAkaGVhZGUgOiBbXSk7XG4gIHJldHVybiBoZWFkZXJHcm91cHM7XG59XG5cbi8vXG5cbi8vXG5cbmNvbnN0IGRlZmF1bHRDb2x1bW5TaXppbmcgPSB7XG4gIHNpemU6IDE1MCxcbiAgbWluU2l6ZTogMjAsXG4gIG1heFNpemU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG59O1xuY29uc3QgZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSA9ICgpID0+ICh7XG4gIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICBzdGFydFNpemU6IG51bGwsXG4gIGRlbHRhT2Zmc2V0OiBudWxsLFxuICBkZWx0YVBlcmNlbnRhZ2U6IG51bGwsXG4gIGlzUmVzaXppbmdDb2x1bW46IGZhbHNlLFxuICBjb2x1bW5TaXppbmdTdGFydDogW11cbn0pO1xuY29uc3QgQ29sdW1uU2l6aW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIGRlZmF1bHRDb2x1bW5TaXppbmc7XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5TaXppbmc6IHt9LFxuICAgICAgY29sdW1uU2l6aW5nSW5mbzogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5SZXNpemVNb2RlOiAnb25FbmQnLFxuICAgICAgb25Db2x1bW5TaXppbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZycsIHRhYmxlKSxcbiAgICAgIG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nSW5mbycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRtaW4sIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJG1heDtcbiAgICAgIGNvbnN0IGNvbHVtblNpemUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ1tjb2x1bW4uaWRdO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChfY29sdW1uJGNvbHVtbkRlZiRtaW4gPSBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtaW4gOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1pblNpemUsIChfcmVmID0gY29sdW1uU2l6ZSAhPSBudWxsID8gY29sdW1uU2l6ZSA6IGNvbHVtbi5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IF9yZWYgOiBkZWZhdWx0Q29sdW1uU2l6aW5nLnNpemUpLCAoX2NvbHVtbiRjb2x1bW5EZWYkbWF4ID0gY29sdW1uLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWF4IDogZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTdGFydCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSAhcG9zaXRpb24gPyB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnbGVmdCcgPyB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucygpO1xuICAgICAgY29uc3QgaW5kZXggPSBjb2x1bW5zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZTaWJsaW5nQ29sdW1uID0gY29sdW1uc1tpbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlNpYmxpbmdDb2x1bW4uZ2V0U3RhcnQocG9zaXRpb24pICsgcHJldlNpYmxpbmdDb2x1bW4uZ2V0U2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBjb2x1bW4ucmVzZXRTaXplID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBbY29sdW1uLmlkXTogXyxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5SZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNSZXNpemluZyA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUhlYWRlcjogKGhlYWRlciwgdGFibGUpID0+IHtcbiAgICBoZWFkZXIuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGhlYWRlciA9PiB7XG4gICAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5mb3JFYWNoKHJlY3Vyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaGVhZGVyJGNvbHVtbiRnZXRTaXo7XG4gICAgICAgICAgc3VtICs9IChfaGVhZGVyJGNvbHVtbiRnZXRTaXogPSBoZWFkZXIuY29sdW1uLmdldFNpemUoKSkgIT0gbnVsbCA/IF9oZWFkZXIkY29sdW1uJGdldFNpeiA6IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWN1cnNlKGhlYWRlcik7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGhlYWRlci5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmdIZWFkZXIgPSBoZWFkZXIuaGVhZGVyR3JvdXAuaGVhZGVyc1toZWFkZXIuaW5kZXggLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nSGVhZGVyLmdldFN0YXJ0KCkgKyBwcmV2U2libGluZ0hlYWRlci5nZXRTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRSZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGhlYWRlci5jb2x1bW4uaWQpO1xuICAgICAgY29uc3QgY2FuUmVzaXplID0gY29sdW1uID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0Q2FuUmVzaXplKCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGlmICghY29sdW1uIHx8ICFjYW5SZXNpemUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIC8vIGxldHMgbm90IHJlc3BvbmQgdG8gbXVsdGlwbGUgdG91Y2hlcyAoZS5nLiAyIG9yIDMgZmluZ2VycylcbiAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0U2l6ZSA9IGhlYWRlci5nZXRTaXplKCk7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemluZ1N0YXJ0ID0gaGVhZGVyID8gaGVhZGVyLmdldExlYWZIZWFkZXJzKCkubWFwKGQgPT4gW2QuY29sdW1uLmlkLCBkLmNvbHVtbi5nZXRTaXplKCldKSA6IFtbY29sdW1uLmlkLCBjb2x1bW4uZ2V0U2l6ZSgpXV07XG4gICAgICAgIGNvbnN0IGNsaWVudFggPSBpc1RvdWNoU3RhcnRFdmVudChlKSA/IE1hdGgucm91bmQoZS50b3VjaGVzWzBdLmNsaWVudFgpIDogZS5jbGllbnRYO1xuICAgICAgICBjb25zdCBuZXdDb2x1bW5TaXppbmcgPSB7fTtcbiAgICAgICAgY29uc3QgdXBkYXRlT2Zmc2V0ID0gKGV2ZW50VHlwZSwgY2xpZW50WFBvcykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2xpZW50WFBvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4ge1xuICAgICAgICAgICAgdmFyIF9vbGQkc3RhcnRPZmZzZXQsIF9vbGQkc3RhcnRTaXplO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSBjbGllbnRYUG9zIC0gKChfb2xkJHN0YXJ0T2Zmc2V0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuc3RhcnRPZmZzZXQpICE9IG51bGwgPyBfb2xkJHN0YXJ0T2Zmc2V0IDogMCk7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVBlcmNlbnRhZ2UgPSBNYXRoLm1heChkZWx0YU9mZnNldCAvICgoX29sZCRzdGFydFNpemUgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydFNpemUpICE9IG51bGwgPyBfb2xkJHN0YXJ0U2l6ZSA6IDApLCAtMC45OTk5OTkpO1xuICAgICAgICAgICAgb2xkLmNvbHVtblNpemluZ1N0YXJ0LmZvckVhY2goX3JlZjMgPT4ge1xuICAgICAgICAgICAgICBsZXQgW2NvbHVtbklkLCBoZWFkZXJTaXplXSA9IF9yZWYzO1xuICAgICAgICAgICAgICBuZXdDb2x1bW5TaXppbmdbY29sdW1uSWRdID0gTWF0aC5yb3VuZChNYXRoLm1heChoZWFkZXJTaXplICsgaGVhZGVyU2l6ZSAqIGRlbHRhUGVyY2VudGFnZSwgMCkgKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICAgIGRlbHRhT2Zmc2V0LFxuICAgICAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplTW9kZSA9PT0gJ29uQ2hhbmdlJyB8fCBldmVudFR5cGUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcob2xkID0+ICh7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgLi4ubmV3Q29sdW1uU2l6aW5nXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbk1vdmUgPSBjbGllbnRYUG9zID0+IHVwZGF0ZU9mZnNldCgnbW92ZScsIGNsaWVudFhQb3MpO1xuICAgICAgICBjb25zdCBvbkVuZCA9IGNsaWVudFhQb3MgPT4ge1xuICAgICAgICAgIHVwZGF0ZU9mZnNldCgnZW5kJywgY2xpZW50WFBvcyk7XG4gICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBzdGFydFNpemU6IG51bGwsXG4gICAgICAgICAgICBkZWx0YU9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgICAgICAgICAgIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4gb25Nb3ZlKGUuY2xpZW50WCksXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgb25FbmQoZS5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvdWNoRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2UkdG91Y2hlcyQ7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uRW5kKChfZSR0b3VjaGVzJCA9IGUudG91Y2hlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJHRvdWNoZXMkLmNsaWVudFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFzc2l2ZUlmU3VwcG9ydGVkID0gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkgPyB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBpZiAoaXNUb3VjaFN0YXJ0RXZlbnQoZSkpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBjbGllbnRYLFxuICAgICAgICAgIHN0YXJ0U2l6ZSxcbiAgICAgICAgICBkZWx0YU9mZnNldDogMCxcbiAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uLmlkXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uU2l6aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0SGVhZGVyU2l6ZUluZm8gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYzI7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMyID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMyIDogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0SGVhZGVyR3JvdXAsIF90YWJsZSRnZXRIZWFkZXJHcm91cDI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRIZWFkZXJHcm91cCA9IChfdGFibGUkZ2V0SGVhZGVyR3JvdXAyID0gdGFibGUuZ2V0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0SGVhZGVyR3JvdXAyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldEhlYWRlckdyb3VwIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldExlZnRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldExlZnRIZWFkZXJHLCBfdGFibGUkZ2V0TGVmdEhlYWRlckcyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0TGVmdEhlYWRlckcgPSAoX3RhYmxlJGdldExlZnRIZWFkZXJHMiA9IHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRMZWZ0SGVhZGVyRzIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0TGVmdEhlYWRlckcgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2VudGVyVG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDZW50ZXJIZWFkZSwgX3RhYmxlJGdldENlbnRlckhlYWRlMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENlbnRlckhlYWRlID0gKF90YWJsZSRnZXRDZW50ZXJIZWFkZTIgPSB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDZW50ZXJIZWFkZTIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0Q2VudGVySGVhZGUgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UmlnaHRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFJpZ2h0SGVhZGVyLCBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0UmlnaHRIZWFkZXIgPSAoX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiA9IHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldFJpZ2h0SGVhZGVyIDogMDtcbiAgICB9O1xuICB9XG59O1xubGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBudWxsO1xuZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3AsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufVxuZnVuY3Rpb24gaXNUb3VjaFN0YXJ0RXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAndG91Y2hzdGFydCc7XG59XG5cbi8vXG5cbmNvbnN0IEV4cGFuZGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGFuZGVkOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeHBhbmRlZENoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZXhwYW5kZWQnLCB0YWJsZSksXG4gICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93czogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRFeHBhbmRlZCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcpIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRFeHBhbmRlZCA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgaWYgKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6ICF0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpKSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUucmVzZXRFeHBhbmRlZCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRlLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRlID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmV4cGFuZGVkKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRlIDoge30pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2FuU29tZVJvd3NFeHBhbmQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhbkV4cGFuZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWUgfHwgT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuXG4gICAgICAvLyBJZiBleHBhbmRlZCBpcyB0cnVlLCBzYXZlIHNvbWUgY3ljbGVzIGFuZCByZXR1cm4gdHJ1ZVxuICAgICAgaWYgKHR5cGVvZiBleHBhbmRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSByb3cgaXMgbm90IGV4cGFuZGVkLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmICh0YWJsZS5nZXRSb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3cuZ2V0SXNFeHBhbmRlZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXkgbXVzdCBhbGwgYmUgZXhwYW5kZWQgOnNocnVnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZERlcHRoID0gKCkgPT4ge1xuICAgICAgbGV0IG1heERlcHRoID0gMDtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQgPT09IHRydWUgPyBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKSA6IE9iamVjdC5rZXlzKHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQpO1xuICAgICAgcm93SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdElkID0gaWQuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4RGVwdGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nIHx8ICF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKG9sZCA9PiB7XG4gICAgICAgIHZhciBfZXhwYW5kZWQ7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG9sZCA9PT0gdHJ1ZSA/IHRydWUgOiAhIShvbGQgIT0gbnVsbCAmJiBvbGRbcm93LmlkXSk7XG4gICAgICAgIGxldCBvbGRFeHBhbmRlZCA9IHt9O1xuICAgICAgICBpZiAob2xkID09PSB0cnVlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaChyb3dJZCA9PiB7XG4gICAgICAgICAgICBvbGRFeHBhbmRlZFtyb3dJZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZEV4cGFuZGVkID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuZGVkID0gKF9leHBhbmRlZCA9IGV4cGFuZGVkKSAhPSBudWxsID8gX2V4cGFuZGVkIDogIWV4aXN0cztcbiAgICAgICAgaWYgKCFleGlzdHMgJiYgZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub2xkRXhwYW5kZWQsXG4gICAgICAgICAgICBbcm93LmlkXTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0cyAmJiAhZXhwYW5kZWQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBbcm93LmlkXTogXyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gb2xkRXhwYW5kZWQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0SXNSO1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuICEhKChfdGFibGUkb3B0aW9ucyRnZXRJc1IgPSB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIDogZXhwYW5kZWQgPT09IHRydWUgfHwgKGV4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiBleHBhbmRlZFtyb3cuaWRdKSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuRXhwYW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfcm93JHN1YlJvd3M7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGxldCBpc0Z1bGx5RXhwYW5kZWQgPSB0cnVlO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAoaXNGdWxseUV4cGFuZGVkICYmIGN1cnJlbnRSb3cucGFyZW50SWQpIHtcbiAgICAgICAgY3VycmVudFJvdyA9IHRhYmxlLmdldFJvdyhjdXJyZW50Um93LnBhcmVudElkLCB0cnVlKTtcbiAgICAgICAgaXNGdWxseUV4cGFuZGVkID0gY3VycmVudFJvdy5nZXRJc0V4cGFuZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdWxseUV4cGFuZGVkO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FuRXhwYW5kKSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBpbmNsdWRlc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgY29uc3Qgc2VhcmNoID0gZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIEJvb2xlYW4oKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlID0gX3JvdyRnZXRWYWx1ZS50b1N0cmluZygpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlID0gX3JvdyRnZXRWYWx1ZS50b0xvd2VyQ2FzZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZS5pbmNsdWRlcyhzZWFyY2gpKTtcbn07XG5pbmNsdWRlc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMjtcbiAgcmV0dXJuIEJvb2xlYW4oKF9yb3ckZ2V0VmFsdWUyID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTIgPSBfcm93JGdldFZhbHVlMi50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTIuaW5jbHVkZXMoZmlsdGVyVmFsdWUpKTtcbn07XG5pbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGVxdWFsc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTM7XG4gIHJldHVybiAoKF9yb3ckZ2V0VmFsdWUzID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTMgPSBfcm93JGdldFZhbHVlMy50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTMudG9Mb3dlckNhc2UoKSkgPT09IChmaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSk7XG59O1xuZXF1YWxzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgYXJySW5jbHVkZXMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWU0O1xuICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU0ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU0LmluY2x1ZGVzKGZpbHRlclZhbHVlKTtcbn07XG5hcnJJbmNsdWRlcy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgYXJySW5jbHVkZXNBbGwgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuICFmaWx0ZXJWYWx1ZS5zb21lKHZhbCA9PiB7XG4gICAgdmFyIF9yb3ckZ2V0VmFsdWU1O1xuICAgIHJldHVybiAhKChfcm93JGdldFZhbHVlNSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgJiYgX3JvdyRnZXRWYWx1ZTUuaW5jbHVkZXModmFsKSk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzQWxsLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc1NvbWUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIGZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTY7XG4gICAgcmV0dXJuIChfcm93JGdldFZhbHVlNiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNi5pbmNsdWRlcyh2YWwpO1xuICB9KTtcbn07XG5hcnJJbmNsdWRlc1NvbWUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGVxdWFscyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PT0gZmlsdGVyVmFsdWU7XG59O1xuZXF1YWxzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3Qgd2Vha0VxdWFscyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PSBmaWx0ZXJWYWx1ZTtcbn07XG53ZWFrRXF1YWxzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5OdW1iZXJSYW5nZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICBsZXQgW21pbiwgbWF4XSA9IGZpbHRlclZhbHVlO1xuICBjb25zdCByb3dWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIHJldHVybiByb3dWYWx1ZSA+PSBtaW4gJiYgcm93VmFsdWUgPD0gbWF4O1xufTtcbmluTnVtYmVyUmFuZ2UucmVzb2x2ZUZpbHRlclZhbHVlID0gdmFsID0+IHtcbiAgbGV0IFt1bnNhZmVNaW4sIHVuc2FmZU1heF0gPSB2YWw7XG4gIGxldCBwYXJzZWRNaW4gPSB0eXBlb2YgdW5zYWZlTWluICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodW5zYWZlTWluKSA6IHVuc2FmZU1pbjtcbiAgbGV0IHBhcnNlZE1heCA9IHR5cGVvZiB1bnNhZmVNYXggIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNYXgpIDogdW5zYWZlTWF4O1xuICBsZXQgbWluID0gdW5zYWZlTWluID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNaW4pID8gLUluZmluaXR5IDogcGFyc2VkTWluO1xuICBsZXQgbWF4ID0gdW5zYWZlTWF4ID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNYXgpID8gSW5maW5pdHkgOiBwYXJzZWRNYXg7XG4gIGlmIChtaW4gPiBtYXgpIHtcbiAgICBjb25zdCB0ZW1wID0gbWluO1xuICAgIG1pbiA9IG1heDtcbiAgICBtYXggPSB0ZW1wO1xuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufTtcbmluTnVtYmVyUmFuZ2UuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgdGVzdEZhbHNleSh2YWxbMF0pICYmIHRlc3RGYWxzZXkodmFsWzFdKTtcblxuLy8gRXhwb3J0XG5cbmNvbnN0IGZpbHRlckZucyA9IHtcbiAgaW5jbHVkZXNTdHJpbmcsXG4gIGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLFxuICBlcXVhbHNTdHJpbmcsXG4gIGFyckluY2x1ZGVzLFxuICBhcnJJbmNsdWRlc0FsbCxcbiAgYXJySW5jbHVkZXNTb21lLFxuICBlcXVhbHMsXG4gIHdlYWtFcXVhbHMsXG4gIGluTnVtYmVyUmFuZ2Vcbn07XG4vLyBVdGlsc1xuXG5mdW5jdGlvbiB0ZXN0RmFsc2V5KHZhbCkge1xuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJyc7XG59XG5cbi8vXG5cbmNvbnN0IEZpbHRlcnMgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5GaWx0ZXJzOiBbXSxcbiAgICAgIGdsb2JhbEZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgLy8gZmlsdGVyc1Byb2dyZXNzOiAxLFxuICAgICAgLy8gZmFjZXRQcm9ncmVzczoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcbiAgICAgIG9uR2xvYmFsRmlsdGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdnbG9iYWxGaWx0ZXInLCB0YWJsZSksXG4gICAgICBmaWx0ZXJGcm9tTGVhZlJvd3M6IGZhbHNlLFxuICAgICAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoOiAxMDAsXG4gICAgICBnbG9iYWxGaWx0ZXJGbjogJ2F1dG8nLFxuICAgICAgZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyOiBjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJGdldENvcmVSb3dNb2RlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXSkgPT0gbnVsbCB8fCAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gX3RhYmxlJGdldENvcmVSb3dNb2RlLl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQoKVtjb2x1bW4uaWRdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvcmVSb3dNb2RlLmdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluTnVtYmVyUmFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmFyckluY2x1ZGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlckZucy53ZWFrRXF1YWxzO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGZpbHRlciwgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMjtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4pID8gY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA6IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4oKSA6IC8vIEB0cy1pZ25vcmVcbiAgICAgIChfdGFibGUkb3B0aW9ucyRmaWx0ZXIgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyMltjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlciA6IGZpbHRlckZuc1tjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5GaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUNvbHVtbkZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYTIsIF90YWJsZSRvcHRpb25zJGVuYWJsZTMsIF90YWJsZSRvcHRpb25zJGVuYWJsZTQsIF90YWJsZSRvcHRpb25zJGdldENvbDtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTQgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGU0IDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRnZXRDb2wgPSB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlciA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIoY29sdW1uKSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldENvbCA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNGaWx0ZXJlZCA9ICgpID0+IGNvbHVtbi5nZXRGaWx0ZXJJbmRleCgpID4gLTE7XG4gICAgY29sdW1uLmdldEZpbHRlclZhbHVlID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0uZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0udmFsdWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVySW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtMiwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0zID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLnNldEZpbHRlclZhbHVlID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyhvbGQgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICBjb25zdCBwcmV2aW91c2ZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKHZhbHVlLCBwcmV2aW91c2ZpbHRlciA/IHByZXZpb3VzZmlsdGVyLnZhbHVlIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAvL1xuICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgbmV3RmlsdGVyLCBjb2x1bW4pKSB7XG4gICAgICAgICAgdmFyIF9vbGQkZmlsdGVyO1xuICAgICAgICAgIHJldHVybiAoX29sZCRmaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX29sZCRmaWx0ZXIgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJPYmogPSB7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmV2aW91c2ZpbHRlcikge1xuICAgICAgICAgIHZhciBfb2xkJG1hcDtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkbWFwID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3RmlsdGVyT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSkpICE9IG51bGwgPyBfb2xkJG1hcCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5vbGQsIG5ld0ZpbHRlck9ial07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuZXdGaWx0ZXJPYmpdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgICAvLyAoKSA9PiBbY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXSxcbiAgICAvLyBmYWNldGVkUm93TW9kZWwgPT4gZ2V0Um93TW9kZWxNaW5NYXhWYWx1ZXMoZmFjZXRlZFJvd01vZGVsLCBjb2x1bW4uaWQpLFxuICB9LFxuXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xuICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIzLCBfdGFibGUkb3B0aW9ucyRmaWx0ZXI0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBnbG9iYWxGaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm5cbiAgICAgIH0gPSB0YWJsZS5vcHRpb25zO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZ2xvYmFsRmlsdGVyRm4pID8gZ2xvYmFsRmlsdGVyRm4gOiBnbG9iYWxGaWx0ZXJGbiA9PT0gJ2F1dG8nID8gdGFibGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMyA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXI0ID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXI0W2dsb2JhbEZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlcjMgOiBmaWx0ZXJGbnNbZ2xvYmFsRmlsdGVyRm5dO1xuICAgIH07XG4gICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpO1xuICAgICAgY29uc3QgdXBkYXRlRm4gPSBvbGQgPT4ge1xuICAgICAgICB2YXIgX2Z1bmN0aW9uYWxVcGRhdGU7XG4gICAgICAgIHJldHVybiAoX2Z1bmN0aW9uYWxVcGRhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCkpID09IG51bGwgPyB2b2lkIDAgOiBfZnVuY3Rpb25hbFVwZGF0ZS5maWx0ZXIoZmlsdGVyID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gZmlsdGVyLmlkKTtcbiAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIGZpbHRlci52YWx1ZSwgY29sdW1uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlKHVwZGF0ZUZuKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlciA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEdsb2JhbEZpbHRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIoZGVmYXVsdFN0YXRlID8gdW5kZWZpbmVkIDogdGFibGUuaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldENvbHVtbkZpbHRlcnMgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIHZhbHVlLCBjb2x1bW4pIHtcbiAgcmV0dXJuIChmaWx0ZXJGbiAmJiBmaWx0ZXJGbi5hdXRvUmVtb3ZlID8gZmlsdGVyRm4uYXV0b1JlbW92ZSh2YWx1ZSwgY29sdW1uKSA6IGZhbHNlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIXZhbHVlO1xufVxuXG5jb25zdCBzdW0gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIC8vIEl0J3MgZmFzdGVyIHRvIGp1c3QgYWRkIHRoZSBhZ2dyZWdhdGlvbnMgdG9nZXRoZXIgaW5zdGVhZCBvZlxuICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XG4gIHJldHVybiBjaGlsZFJvd3MucmVkdWNlKChzdW0sIG5leHQpID0+IHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICByZXR1cm4gc3VtICsgKHR5cGVvZiBuZXh0VmFsdWUgPT09ICdudW1iZXInID8gbmV4dFZhbHVlIDogMCk7XG4gIH0sIDApO1xufTtcbmNvbnN0IG1pbiA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkge1xuICAgICAgbWluID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1pbjtcbn07XG5jb25zdCBtYXggPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtYXg7XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCBtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1heCA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXg7XG59O1xuY29uc3QgZXh0ZW50ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWluO1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbbWluLCBtYXhdO1xufTtcbmNvbnN0IG1lYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBzdW0gPSAwO1xuICBsZWFmUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgbGV0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvdW50KSByZXR1cm4gc3VtIC8gY291bnQ7XG4gIHJldHVybjtcbn07XG5jb25zdCBtZWRpYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIGlmICghbGVhZlJvd3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IGxlYWZSb3dzLm1hcChyb3cgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSk7XG4gIGlmICghaXNOdW1iZXJBcnJheSh2YWx1ZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfVxuICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgY29uc3QgbnVtcyA9IHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIHJldHVybiB2YWx1ZXMubGVuZ3RoICUgMiAhPT0gMCA/IG51bXNbbWlkXSA6IChudW1zW21pZCAtIDFdICsgbnVtc1ttaWRdKSAvIDI7XG59O1xuY29uc3QgdW5pcXVlID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkudmFsdWVzKCkpO1xufTtcbmNvbnN0IHVuaXF1ZUNvdW50ID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnNpemU7XG59O1xuY29uc3QgY291bnQgPSAoX2NvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbGVhZlJvd3MubGVuZ3RoO1xufTtcbmNvbnN0IGFnZ3JlZ2F0aW9uRm5zID0ge1xuICBzdW0sXG4gIG1pbixcbiAgbWF4LFxuICBleHRlbnQsXG4gIG1lYW4sXG4gIG1lZGlhbixcbiAgdW5pcXVlLFxuICB1bmlxdWVDb3VudCxcbiAgY291bnRcbn07XG5cbi8vXG5cbmNvbnN0IEdyb3VwaW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFnZ3JlZ2F0ZWRDZWxsOiBwcm9wcyA9PiB7XG4gICAgICAgIHZhciBfdG9TdHJpbmcsIF9wcm9wcyRnZXRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIChfdG9TdHJpbmcgPSAoX3Byb3BzJGdldFZhbHVlID0gcHJvcHMuZ2V0VmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3RvU3RyaW5nIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBhZ2dyZWdhdGlvbkZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ3JvdXBpbmc6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkdyb3VwaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdncm91cGluZycsIHRhYmxlKSxcbiAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlOiAncmVvcmRlcidcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZUdyb3VwaW5nID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcob2xkID0+IHtcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3RpbmcgZ3JvdXBpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQuaW5jbHVkZXMoY29sdW1uLmlkKSkge1xuICAgICAgICAgIHJldHVybiBvbGQuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLihvbGQgIT0gbnVsbCA/IG9sZCA6IFtdKSwgY29sdW1uLmlkXTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkdyb3VwID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9yZWYyLCBfcmVmMywgX2NvbHVtbiRjb2x1bW5EZWYkZW5hO1xuICAgICAgcmV0dXJuIChfcmVmID0gKF9yZWYyID0gKF9yZWYzID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAhPSBudWxsID8gX3JlZjMgOiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX3JlZjIgOiB0cnVlKSAhPSBudWxsID8gX3JlZiA6ICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNHcm91cGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRncm91cDtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cC5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldEdyb3VwZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cDIuaW5kZXhPZihjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkdyb3VwID0gY29sdW1uLmdldENhbkdyb3VwKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkdyb3VwKSByZXR1cm47XG4gICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLnN1bTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLmV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGFnZ3JlZywgX3RhYmxlJG9wdGlvbnMkYWdncmVnMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA6IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkYWdncmVnID0gKF90YWJsZSRvcHRpb25zJGFnZ3JlZzIgPSB0YWJsZS5vcHRpb25zLmFnZ3JlZ2F0aW9uRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkYWdncmVnMltjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYWdncmVnIDogYWdncmVnYXRpb25GbnNbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldEdyb3VwaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldEdyb3VwaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGcsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGcgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZ3JvdXBpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGcgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxHcm91cGluZyB8fCAhdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuZ2V0SXNHcm91cGVkID0gKCkgPT4gISFyb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICByb3cuZ2V0R3JvdXBpbmdWYWx1ZSA9IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgICB9XG4gICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKHJvdy5vcmlnaW5hbCk7XG4gICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9O1xuICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZSA9IHt9O1xuICB9LFxuICBjcmVhdGVDZWxsOiAoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKSA9PiB7XG4gICAgY2VsbC5nZXRJc0dyb3VwZWQgPSAoKSA9PiBjb2x1bW4uZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmlkID09PSByb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICBjZWxsLmdldElzUGxhY2Vob2xkZXIgPSAoKSA9PiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiBjb2x1bW4uZ2V0SXNHcm91cGVkKCk7XG4gICAgY2VsbC5nZXRJc0FnZ3JlZ2F0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgcmV0dXJuICFjZWxsLmdldElzR3JvdXBlZCgpICYmICFjZWxsLmdldElzUGxhY2Vob2xkZXIoKSAmJiAhISgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gIGlmICghKGdyb3VwaW5nICE9IG51bGwgJiYgZ3JvdXBpbmcubGVuZ3RoKSB8fCAhZ3JvdXBlZENvbHVtbk1vZGUpIHtcbiAgICByZXR1cm4gbGVhZkNvbHVtbnM7XG4gIH1cbiAgY29uc3Qgbm9uR3JvdXBpbmdDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbCA9PiAhZ3JvdXBpbmcuaW5jbHVkZXMoY29sLmlkKSk7XG4gIGlmIChncm91cGVkQ29sdW1uTW9kZSA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gbm9uR3JvdXBpbmdDb2x1bW5zO1xuICB9XG4gIGNvbnN0IGdyb3VwaW5nQ29sdW1ucyA9IGdyb3VwaW5nLm1hcChnID0+IGxlYWZDb2x1bW5zLmZpbmQoY29sID0+IGNvbC5pZCA9PT0gZykpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFsuLi5ncm91cGluZ0NvbHVtbnMsIC4uLm5vbkdyb3VwaW5nQ29sdW1uc107XG59XG5cbi8vXG5cbmNvbnN0IE9yZGVyaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uT3JkZXI6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbk9yZGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5PcmRlcicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uT3JkZXIgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtbk9yZGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uT3JkZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtbk9yZGVyKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlcikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbiA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuY29sdW1uT3JkZXIsIHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLm9wdGlvbnMuZ3JvdXBlZENvbHVtbk1vZGVdLCAoY29sdW1uT3JkZXIsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkgPT4gY29sdW1ucyA9PiB7XG4gICAgICAvLyBTb3J0IGdyb3VwZWQgY29sdW1ucyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbHVtbiBsaXN0XG4gICAgICAvLyBiZWZvcmUgdGhlIGhlYWRlcnMgYXJlIGJ1aWx0XG4gICAgICBsZXQgb3JkZXJlZENvbHVtbnMgPSBbXTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb3JkZXIsIHJldHVybiB0aGUgbm9ybWFsIGNvbHVtbnNcbiAgICAgIGlmICghKGNvbHVtbk9yZGVyICE9IG51bGwgJiYgY29sdW1uT3JkZXIubGVuZ3RoKSkge1xuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2x1bW5PcmRlckNvcHkgPSBbLi4uY29sdW1uT3JkZXJdO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yZGVyLCBtYWtlIGEgY29weSBvZiB0aGUgY29sdW1uc1xuICAgICAgICBjb25zdCBjb2x1bW5zQ29weSA9IFsuLi5jb2x1bW5zXTtcblxuICAgICAgICAvLyBBbmQgbWFrZSBhIG5ldyBvcmRlcmVkIGFycmF5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBjb2x1bW5zIGFuZCBwbGFjZSB0aGVtIGluIG9yZGVyIGludG8gdGhlIG5ldyBhcnJheVxuICAgICAgICB3aGlsZSAoY29sdW1uc0NvcHkubGVuZ3RoICYmIGNvbHVtbk9yZGVyQ29weS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW5JZCA9IGNvbHVtbk9yZGVyQ29weS5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kSW5kZXggPSBjb2x1bW5zQ29weS5maW5kSW5kZXgoZCA9PiBkLmlkID09PSB0YXJnZXRDb2x1bW5JZCk7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgb3JkZXJlZENvbHVtbnMucHVzaChjb2x1bW5zQ29weS5zcGxpY2UoZm91bmRJbmRleCwgMSlbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgY29sdW1ucyBsZWZ0LCBhZGQgdGhlbSB0byB0aGUgZW5kXG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gWy4uLm9yZGVyZWRDb2x1bW5zLCAuLi5jb2x1bW5zQ29weV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKG9yZGVyZWRDb2x1bW5zLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldE9yZGVyQ29sdW1uc0ZuJ1xuICAgICAgLy8gZGVidWc6ICgpID0+IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwgPz8gdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlLFxuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0UGFnZUluZGV4ID0gMDtcbmNvbnN0IGRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xuY29uc3QgZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSA9ICgpID0+ICh7XG4gIHBhZ2VJbmRleDogZGVmYXVsdFBhZ2VJbmRleCxcbiAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZVxufSk7XG5jb25zdCBQYWdpbmF0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIC4uLmdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSxcbiAgICAgICAgLi4uKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5wYWdpbmF0aW9uKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUGFnaW5hdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncGFnaW5hdGlvbicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0UGFnZUluZGV4KSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4KCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0UGFnaW5hdGlvbiA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3Qgc2FmZVVwZGF0ZXIgPSBvbGQgPT4ge1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCk7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKHNhZmVVcGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnaW5hdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwO1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwID0gdGFibGUuaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAgOiBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBwYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlSW5kZXgpO1xuICAgICAgICBjb25zdCBtYXhQYWdlSW5kZXggPSB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAtMSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGFibGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xuICAgICAgICBwYWdlSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSW5kZXgsIG1heFBhZ2VJbmRleCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlSW5kZXggPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDIsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRQYWdlSW5kZXgoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VJbmRleCA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAyID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUgPSBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDIgOiBkZWZhdWx0UGFnZUluZGV4KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDMsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgdGFibGUuc2V0UGFnZVNpemUoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VTaXplIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUyID0gX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2VTaXplKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA6IGRlZmF1bHRQYWdlU2l6ZSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlU2l6ZSA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSk7XG4gICAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gb2xkLnBhZ2VTaXplICogb2xkLnBhZ2VJbmRleDtcbiAgICAgICAgY29uc3QgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VDb3VudCA9IHVwZGF0ZXIgPT4gdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbztcbiAgICAgIGxldCBuZXdQYWdlQ291bnQgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIChfdGFibGUkb3B0aW9ucyRwYWdlQ28gPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbyA6IC0xKTtcbiAgICAgIGlmICh0eXBlb2YgbmV3UGFnZUNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBuZXdQYWdlQ291bnQgPSBNYXRoLm1heCgtMSwgbmV3UGFnZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgcGFnZUNvdW50OiBuZXdQYWdlQ291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UGFnZU9wdGlvbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRQYWdlQ291bnQoKV0sIHBhZ2VDb3VudCA9PiB7XG4gICAgICBsZXQgcGFnZU9wdGlvbnMgPSBbXTtcbiAgICAgIGlmIChwYWdlQ291bnQgJiYgcGFnZUNvdW50ID4gMCkge1xuICAgICAgICBwYWdlT3B0aW9ucyA9IFsuLi5uZXcgQXJyYXkocGFnZUNvdW50KV0uZmlsbChudWxsKS5tYXAoKF8sIGkpID0+IGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VPcHRpb25zO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFBhZ2VPcHRpb25zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDYW5QcmV2aW91c1BhZ2UgPSAoKSA9PiB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZUluZGV4ID4gMDtcbiAgICB0YWJsZS5nZXRDYW5OZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZUluZGV4XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uO1xuICAgICAgY29uc3QgcGFnZUNvdW50ID0gdGFibGUuZ2V0UGFnZUNvdW50KCk7XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VJbmRleCA8IHBhZ2VDb3VudCAtIDE7XG4gICAgfTtcbiAgICB0YWJsZS5wcmV2aW91c1BhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiBvbGQgLSAxKTtcbiAgICB9O1xuICAgIHRhYmxlLm5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4ge1xuICAgICAgICByZXR1cm4gb2xkICsgMTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbiB8fCAhdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UGFnZUNvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJHBhZ2VDbzIgPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbzIgOiBNYXRoLmNlaWwodGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGggLyB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZVNpemUpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICBsZWZ0OiBbXSxcbiAgcmlnaHQ6IFtdXG59KTtcbmNvbnN0IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdXG59KTtcbmNvbnN0IFBpbm5pbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5QaW5uaW5nOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCksXG4gICAgICByb3dQaW5uaW5nOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uUGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uUGlubmluZycsIHRhYmxlKSxcbiAgICAgIG9uUm93UGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93UGlubmluZycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4ucGluID0gcG9zaXRpb24gPT4ge1xuICAgICAgY29uc3QgY29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCRsZWZ0MywgX29sZCRyaWdodDM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHZhciBfb2xkJGxlZnQsIF9vbGQkcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdCA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxuICAgICAgICAgICAgcmlnaHQ6IFsuLi4oKF9vbGQkcmlnaHQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0MiwgX29sZCRyaWdodDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IFsuLi4oKF9vbGQkbGVmdDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLCAuLi5jb2x1bW5JZHNdLFxuICAgICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICByaWdodDogKChfb2xkJHJpZ2h0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKTtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5zb21lKGQgPT4ge1xuICAgICAgICB2YXIgX2QkY29sdW1uRGVmJGVuYWJsZVBpLCBfcmVmLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICAgIHJldHVybiAoKF9kJGNvbHVtbkRlZiRlbmFibGVQaSA9IGQuY29sdW1uRGVmLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfZCRjb2x1bW5EZWYkZW5hYmxlUGkgOiB0cnVlKSAmJiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdGFibGUub3B0aW9ucy5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZiA6IHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgY29uc3QgaXNMZWZ0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc1JpZ2h0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0LmluY2x1ZGVzKGQpKTtcbiAgICAgIHJldHVybiBpc0xlZnQgPyAnbGVmdCcgOiBpc1JpZ2h0ID8gJ3JpZ2h0JyA6IGZhbHNlO1xuICAgIH07XG4gICAgY29sdW1uLmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29sdW1uLmdldElzUGlubmVkKCk7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPyAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0yW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIuaW5kZXhPZihjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtIDogLTEgOiAwO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cucGluID0gKHBvc2l0aW9uLCBpbmNsdWRlTGVhZlJvd3MsIGluY2x1ZGVQYXJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBsZWFmUm93SWRzID0gaW5jbHVkZUxlYWZSb3dzID8gcm93LmdldExlYWZSb3dzKCkubWFwKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCBwYXJlbnRSb3dJZHMgPSBpbmNsdWRlUGFyZW50Um93cyA/IHJvdy5nZXRQYXJlbnRSb3dzKCkubWFwKF9yZWYzID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCByb3dJZHMgPSBuZXcgU2V0KFsuLi5wYXJlbnRSb3dJZHMsIHJvdy5pZCwgLi4ubGVhZlJvd0lkc10pO1xuICAgICAgdGFibGUuc2V0Um93UGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCR0b3AzLCBfb2xkJGJvdHRvbTM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AsIF9vbGQkYm90dG9tO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6ICgoX29sZCR0b3AgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcCA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcbiAgICAgICAgICAgIGJvdHRvbTogWy4uLigoX29sZCRib3R0b20gPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbSA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSwgLi4uQXJyYXkuZnJvbShyb3dJZHMpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIHZhciBfb2xkJHRvcDIsIF9vbGQkYm90dG9tMjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBbLi4uKChfb2xkJHRvcDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDIgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV0sXG4gICAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20yID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20yIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogKChfb2xkJHRvcDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWY0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmFibGVSb3dQaW5uaW5nLFxuICAgICAgICBlbmFibGVQaW5uaW5nXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgZW5hYmxlUm93UGlubmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZW5hYmxlUm93UGlubmluZyhyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfcmVmNCA9IGVuYWJsZVJvd1Bpbm5pbmcgIT0gbnVsbCA/IGVuYWJsZVJvd1Bpbm5pbmcgOiBlbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZjQgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm93SWRzID0gW3Jvdy5pZF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgY29uc3QgaXNUb3AgPSByb3dJZHMuc29tZShkID0+IHRvcCA9PSBudWxsID8gdm9pZCAwIDogdG9wLmluY2x1ZGVzKGQpKTtcbiAgICAgIGNvbnN0IGlzQm90dG9tID0gcm93SWRzLnNvbWUoZCA9PiBib3R0b20gPT0gbnVsbCA/IHZvaWQgMCA6IGJvdHRvbS5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNUb3AgPyAndG9wJyA6IGlzQm90dG9tID8gJ2JvdHRvbScgOiBmYWxzZTtcbiAgICB9O1xuICAgIHJvdy5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkX2dldFBpbm5lZFJvd3MsIF92aXNpYmxlUGlubmVkUm93SWRzJDtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcm93LmdldElzUGlubmVkKCk7XG4gICAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gLTE7XG4gICAgICBjb25zdCB2aXNpYmxlUGlubmVkUm93SWRzID0gKF90YWJsZSRfZ2V0UGlubmVkUm93cyA9IHRhYmxlLl9nZXRQaW5uZWRSb3dzKHBvc2l0aW9uKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRfZ2V0UGlubmVkUm93cy5tYXAoX3JlZjUgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmNTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKF92aXNpYmxlUGlubmVkUm93SWRzJCA9IHZpc2libGVQaW5uZWRSb3dJZHMgPT0gbnVsbCA/IHZvaWQgMCA6IHZpc2libGVQaW5uZWRSb3dJZHMuaW5kZXhPZihyb3cuaWQpKSAhPSBudWxsID8gX3Zpc2libGVQaW5uZWRSb3dJZHMkIDogLTE7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ2VsbHMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmNvbHVtbi5pZCkpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ3Jvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm93LmdldExlZnRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwsXSwgKGFsbENlbGxzLCBsZWZ0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAnbGVmdCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0TGVmdFZpc2libGVDZWxscycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb246ICdyaWdodCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uUGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldENvbHVtblBpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRsZWZ0LCBfcGlubmluZ1N0YXRlJHJpZ2h0O1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkbGVmdCA9IHBpbm5pbmdTdGF0ZS5sZWZ0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRsZWZ0Lmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJHJpZ2h0ID0gcGlubmluZ1N0YXRlLnJpZ2h0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRyaWdodC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWZ0KSA9PiB7XG4gICAgICByZXR1cm4gKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0TGVhZkNvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTQ7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0IDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSaWdodExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTUgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5pZCkpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckxlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTYgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNiA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1Bpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkciwgX3RhYmxlJGluaXRpYWxTdGF0ZTI7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93UGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZTIucm93UGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbzI7XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJHRvcCwgX3Bpbm5pbmdTdGF0ZSRib3R0b207XG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSR0b3AgPSBwaW5uaW5nU3RhdGUudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSR0b3AubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkYm90dG9tID0gcGlubmluZ1N0YXRlLmJvdHRvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkYm90dG9tLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbzIgPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvMi5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldFBpbm5lZFJvd3MgPSBwb3NpdGlvbiA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZ1twb3NpdGlvbl1dLCAodmlzaWJsZVJvd3MsIHBpbm5lZFJvd0lkcykgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGtlZXBQaTtcbiAgICAgIGNvbnN0IHJvd3MgPSAoKF90YWJsZSRvcHRpb25zJGtlZXBQaSA9IHRhYmxlLm9wdGlvbnMua2VlcFBpbm5lZFJvd3MpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRrZWVwUGkgOiB0cnVlKSA/XG4gICAgICAvL2dldCBhbGwgcm93cyB0aGF0IGFyZSBwaW5uZWQgZXZlbiBpZiB0aGV5IHdvdWxkIG5vdCBiZSBvdGhlcndpc2UgdmlzaWJsZVxuICAgICAgLy9hY2NvdW50IGZvciBleHBhbmRlZCBwYXJlbnQgcm93cywgYnV0IG5vdCBwYWdpbmF0aW9uIG9yIGZpbHRlcmluZ1xuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQoKSA/IHJvdyA6IG51bGw7XG4gICAgICB9KSA6XG4gICAgICAvL2Vsc2UgZ2V0IG9ubHkgdmlzaWJsZSByb3dzIHRoYXQgYXJlIHBpbm5lZFxuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB2aXNpYmxlUm93cy5maW5kKHJvdyA9PiByb3cuaWQgPT09IHJvd0lkKSk7XG4gICAgICByZXR1cm4gcm93cy5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIH0pKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGByb3cuZ2V0JHtwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnVG9wJyA6ICdCb3R0b20nfVJvd3NgLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTc7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3IDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICB0YWJsZS5nZXRUb3BSb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ3RvcCcpO1xuICAgIHRhYmxlLmdldEJvdHRvbVJvd3MgPSAoKSA9PiB0YWJsZS5fZ2V0UGlubmVkUm93cygnYm90dG9tJyk7XG4gICAgdGFibGUuZ2V0Q2VudGVyUm93cyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLnRvcCwgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLmJvdHRvbV0sIChhbGxSb3dzLCB0b3AsIGJvdHRvbSkgPT4ge1xuICAgICAgY29uc3QgdG9wQW5kQm90dG9tID0gbmV3IFNldChbLi4uKHRvcCAhPSBudWxsID8gdG9wIDogW10pLCAuLi4oYm90dG9tICE9IG51bGwgPyBib3R0b20gOiBbXSldKTtcbiAgICAgIHJldHVybiBhbGxSb3dzLmZpbHRlcihkID0+ICF0b3BBbmRCb3R0b20uaGFzKGQuaWQpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0Q2VudGVyUm93cycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBODtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTggOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgUm93U2VsZWN0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcm93U2VsZWN0aW9uOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1NlbGVjdGlvbicsIHRhYmxlKSxcbiAgICAgIGVuYWJsZVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlU3ViUm93U2VsZWN0aW9uOiB0cnVlXG4gICAgICAvLyBlbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAvLyBpc0FkZGl0aXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUubWV0YUtleSxcbiAgICAgIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUuc2hpZnRLZXksXG4gICAgfTtcbiAgfSxcblxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbiA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1NlbGVjdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRyO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1NlbGVjdGlvbihkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHIgPSB0YWJsZS5pbml0aWFsU3RhdGUucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRyIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICAuLi5vbGRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCkuZmxhdFJvd3M7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGBtdXRhdGVSb3dJc1NlbGVjdGVkYCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgICAgICAvLyBBbGwgb2YgdGhlIHJvd3MgYXJlIGZsYXQgYWxyZWFkeSwgc28gaXQgd291bGRuJ3QgYmUgd29ydGggaXRcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGlmICghcm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbltyb3cuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHJvd1NlbGVjdGlvbltyb3cuaWRdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQgPSB2YWx1ZSA9PiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCk7XG4gICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgIC4uLm9sZFxuICAgICAgfTtcbiAgICAgIHRhYmxlLmdldFJvd01vZGVsKCkucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQocm93U2VsZWN0aW9uLCByb3cuaWQsIHJlc29sdmVkVmFsdWUsIHRydWUsIHRhYmxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcbiAgICB9KTtcblxuICAgIC8vIGFkZFJvd1NlbGVjdGlvblJhbmdlOiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCB7XG4gICAgLy8gICAgIHJvd3MsXG4gICAgLy8gICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICBvcHRpb25zOiB7IHNlbGVjdEdyb3VwaW5nUm93cywgc2VsZWN0U3ViUm93cyB9LFxuICAgIC8vICAgfSA9IHRhYmxlXG5cbiAgICAvLyAgIGNvbnN0IGZpbmRTZWxlY3RlZFJvdyA9IChyb3dzOiBSb3dbXSkgPT4ge1xuICAgIC8vICAgICBsZXQgZm91bmRcbiAgICAvLyAgICAgcm93cy5maW5kKGQgPT4ge1xuICAgIC8vICAgICAgIGlmIChkLmdldElzU2VsZWN0ZWQoKSkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBkXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICBjb25zdCBzdWJGb3VuZCA9IGZpbmRTZWxlY3RlZFJvdyhkLnN1YlJvd3MgfHwgW10pXG4gICAgLy8gICAgICAgaWYgKHN1YkZvdW5kKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IHN1YkZvdW5kXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICByZXR1cm4gZmFsc2VcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgICAgcmV0dXJuIGZvdW5kXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGNvbnN0IGZpcnN0Um93ID0gZmluZFNlbGVjdGVkUm93KHJvd3MpIHx8IHJvd3NbMF1cbiAgICAvLyAgIGNvbnN0IGxhc3RSb3cgPSByb3dzQnlJZFtyb3dJZF1cblxuICAgIC8vICAgbGV0IGluY2x1ZGUgPSBmYWxzZVxuICAgIC8vICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7fVxuXG4gICAgLy8gICBjb25zdCBhZGRSb3cgPSAocm93OiBSb3cpID0+IHtcbiAgICAvLyAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB0cnVlLCB7XG4gICAgLy8gICAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgICAgc2VsZWN0R3JvdXBpbmdSb3dzOiBzZWxlY3RHcm91cGluZ1Jvd3MhLFxuICAgIC8vICAgICAgIHNlbGVjdFN1YlJvd3M6IHNlbGVjdFN1YlJvd3MhLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgfVxuXG4gICAgLy8gICB0YWJsZS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAvLyAgICAgY29uc3QgaXNGaXJzdFJvdyA9IHJvdy5pZCA9PT0gZmlyc3RSb3cuaWRcbiAgICAvLyAgICAgY29uc3QgaXNMYXN0Um93ID0gcm93LmlkID09PSBsYXN0Um93LmlkXG5cbiAgICAvLyAgICAgaWYgKGlzRmlyc3RSb3cgfHwgaXNMYXN0Um93KSB7XG4gICAgLy8gICAgICAgaWYgKCFpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gdHJ1ZVxuICAgIC8vICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgYWRkUm93KHJvdylcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSBmYWxzZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgYWRkUm93KHJvdylcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSlcblxuICAgIC8vICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKHNlbGVjdGVkUm93SWRzKVxuICAgIC8vIH0sXG4gICAgdGFibGUuZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0Q29yZVJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRTZWxlY3RlZFJvd01vZGVsJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldFNvcnRlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ2dldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vL1xuXG4gICAgLy8gZ2V0R3JvdXBpbmdSb3dDYW5TZWxlY3Q6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZClcblxuICAgIC8vICAgaWYgKCFyb3cpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAvLyAgIH1cblxuICAgIC8vICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKHJvdylcbiAgICAvLyAgIH1cblxuICAgIC8vICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPz8gZmFsc2VcbiAgICAvLyB9LFxuXG4gICAgdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3M7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICBsZXQgaXNBbGxSb3dzU2VsZWN0ZWQgPSBCb29sZWFuKHByZUdyb3VwZWRGbGF0Um93cy5sZW5ndGggJiYgT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpO1xuICAgICAgaWYgKGlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICAgIGlmIChwcmVHcm91cGVkRmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhblNlbGVjdCgpICYmICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgICBpc0FsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICBsZXQgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gISFwYWdpbmF0aW9uRmxhdFJvd3MubGVuZ3RoO1xuICAgICAgaWYgKGlzQWxsUGFnZVJvd3NTZWxlY3RlZCAmJiBwYWdpbmF0aW9uRmxhdFJvd3Muc29tZShyb3cgPT4gIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xuICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHJvd1NlO1xuICAgICAgY29uc3QgdG90YWxTZWxlY3RlZCA9IE9iamVjdC5rZXlzKChfdGFibGUkZ2V0U3RhdGUkcm93U2UgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA6IHt9KS5sZW5ndGg7XG4gICAgICByZXR1cm4gdG90YWxTZWxlY3RlZCA+IDAgJiYgdG90YWxTZWxlY3RlZCA8IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5sZW5ndGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3M7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCkgPyBmYWxzZSA6IHBhZ2luYXRpb25GbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSkuc29tZShkID0+IGQuZ2V0SXNTZWxlY3RlZCgpIHx8IGQuZ2V0SXNTb21lU2VsZWN0ZWQoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cudG9nZ2xlU2VsZWN0ZWQgPSAodmFsdWUsIG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSByb3cuZ2V0SXNTZWxlY3RlZCgpO1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb3B0cyRzZWxlY3RDaGlsZHJlbjtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhaXNTZWxlY3RlZDtcbiAgICAgICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSAmJiBpc1NlbGVjdGVkID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdmFsdWUsIChfb3B0cyRzZWxlY3RDaGlsZHJlbiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuc2VsZWN0Q2hpbGRyZW4pICE9IG51bGwgPyBfb3B0cyRzZWxlY3RDaGlsZHJlbiA6IHRydWUsIHRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUm93SWRzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1NvbWVTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ3NvbWUnO1xuICAgIH07XG4gICAgcm93LmdldElzQWxsU3ViUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnYWxsJztcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldENhblNlbGVjdFN1YlJvd3MgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldENhbk11bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRUb2dnbGVTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5TZWxlY3QgPSByb3cuZ2V0Q2FuU2VsZWN0KCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICBpZiAoIWNhblNlbGVjdCkgcmV0dXJuO1xuICAgICAgICByb3cudG9nZ2xlU2VsZWN0ZWQoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBtdXRhdGVSb3dJc1NlbGVjdGVkID0gKHNlbGVjdGVkUm93SWRzLCBpZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpID0+IHtcbiAgdmFyIF9yb3ckc3ViUm93cztcbiAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KGlkKTtcblxuICAvLyBjb25zdCBpc0dyb3VwZWQgPSByb3cuZ2V0SXNHcm91cGVkKClcblxuICAvLyBpZiAoIC8vIFRPRE86IGVuZm9yY2UgZ3JvdXBpbmcgcm93IHNlbGVjdGlvbiBydWxlc1xuICAvLyAgICFpc0dyb3VwZWQgfHxcbiAgLy8gICAoaXNHcm91cGVkICYmIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24pXG4gIC8vICkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIXJvdy5nZXRDYW5NdWx0aVNlbGVjdCgpKSB7XG4gICAgICBPYmplY3Qua2V5cyhzZWxlY3RlZFJvd0lkcykuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHNlbGVjdGVkUm93SWRzW2tleV0pO1xuICAgIH1cbiAgICBpZiAocm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBzZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICB9XG4gIC8vIH1cblxuICBpZiAoaW5jbHVkZUNoaWxkcmVuICYmIChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzKCkpIHtcbiAgICByb3cuc3ViUm93cy5mb3JFYWNoKHJvdyA9PiBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKSB7XG4gIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uO1xuICBjb25zdCBuZXdTZWxlY3RlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld1NlbGVjdGVkUm93c0J5SWQgPSB7fTtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZVJvd3MgPSBmdW5jdGlvbiAocm93cywgZGVwdGgpIHtcbiAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pO1xuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgbmV3U2VsZWN0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld1NlbGVjdGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICAgIGlmICgoX3JvdyRzdWJSb3dzMiA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czIubGVuZ3RoKSB7XG4gICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgc3ViUm93czogcmVjdXJzZVJvd3Mocm93LnN1YlJvd3MpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfVxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlUm93cyhyb3dNb2RlbC5yb3dzKSxcbiAgICBmbGF0Um93czogbmV3U2VsZWN0ZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3U2VsZWN0ZWRSb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbikge1xuICB2YXIgX3NlbGVjdGlvbiRyb3ckaWQ7XG4gIHJldHVybiAoX3NlbGVjdGlvbiRyb3ckaWQgPSBzZWxlY3Rpb25bcm93LmlkXSkgIT0gbnVsbCA/IF9zZWxlY3Rpb24kcm93JGlkIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgc2VsZWN0aW9uLCB0YWJsZSkge1xuICB2YXIgX3JvdyRzdWJSb3dzMztcbiAgaWYgKCEoKF9yb3ckc3ViUm93czMgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MzLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcbiAgbGV0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSB0cnVlO1xuICBsZXQgc29tZVNlbGVjdGVkID0gZmFsc2U7XG4gIHJvdy5zdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAvLyBCYWlsIG91dCBlYXJseSBpZiB3ZSBrbm93IGJvdGggb2YgdGhlc2VcbiAgICBpZiAoc29tZVNlbGVjdGVkICYmICFhbGxDaGlsZHJlblNlbGVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJSb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgIGlmIChpc1Jvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKSkge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHJvdyBzZWxlY3Rpb24gb2YgbmVzdGVkIHN1YnJvd3NcbiAgICBpZiAoc3ViUm93LnN1YlJvd3MgJiYgc3ViUm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJSb3dDaGlsZHJlblNlbGVjdGVkID0gaXNTdWJSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbik7XG4gICAgICBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ3NvbWUnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYWxsQ2hpbGRyZW5TZWxlY3RlZCA/ICdhbGwnIDogc29tZVNlbGVjdGVkID8gJ3NvbWUnIDogZmFsc2U7XG59XG5cbmNvbnN0IHJlU3BsaXRBbHBoYU51bWVyaWMgPSAvKFswLTldKykvZ207XG5jb25zdCBhbHBoYW51bWVyaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5jb25zdCBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5cbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcbi8vIGJ1dCBpcyBtdWNoIGZhc3RlclxuY29uc3QgdGV4dCA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHRDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xufTtcbmNvbnN0IGRhdGV0aW1lID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIGNvbnN0IGEgPSByb3dBLmdldFZhbHVlKGNvbHVtbklkKTtcbiAgY29uc3QgYiA9IHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpO1xuXG4gIC8vIENhbiBoYW5kbGUgbnVsbGlzaCB2YWx1ZXNcbiAgLy8gVXNlID4gYW5kIDwgYmVjYXVzZSA9PSAoYW5kID09PSkgZG9lc24ndCB3b3JrIHdpdGhcbiAgLy8gRGF0ZSBvYmplY3RzICh3b3VsZCByZXF1aXJlIGNhbGxpbmcgZ2V0VGltZSgpKS5cbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcbmNvbnN0IGJhc2ljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWMocm93QS5nZXRWYWx1ZShjb2x1bW5JZCksIHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKTtcbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIGNvbXBhcmVCYXNpYyhhLCBiKSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IEluZmluaXR5IHx8IGEgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8vIE1peGVkIHNvcnRpbmcgaXMgc2xvdywgYnV0IHZlcnkgaW5jbHVzaXZlIG9mIG1hbnkgZWRnZSBjYXNlcy5cbi8vIEl0IGhhbmRsZXMgbnVtYmVycywgbWl4ZWQgYWxwaGFudW1lcmljIGNvbWJpbmF0aW9ucywgYW5kIGV2ZW5cbi8vIG51bGwsIHVuZGVmaW5lZCwgYW5kIEluZmluaXR5XG5mdW5jdGlvbiBjb21wYXJlQWxwaGFudW1lcmljKGFTdHIsIGJTdHIpIHtcbiAgLy8gU3BsaXQgb24gbnVtYmVyIGdyb3VwcywgYnV0IGtlZXAgdGhlIGRlbGltaXRlclxuICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXG4gIGNvbnN0IGEgPSBhU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgYiA9IGJTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIC8vIFdoaWxlXG4gIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgIGNvbnN0IGFhID0gYS5zaGlmdCgpO1xuICAgIGNvbnN0IGJiID0gYi5zaGlmdCgpO1xuICAgIGNvbnN0IGFuID0gcGFyc2VJbnQoYWEsIDEwKTtcbiAgICBjb25zdCBibiA9IHBhcnNlSW50KGJiLCAxMCk7XG4gICAgY29uc3QgY29tYm8gPSBbYW4sIGJuXS5zb3J0KCk7XG5cbiAgICAvLyBCb3RoIGFyZSBzdHJpbmdcbiAgICBpZiAoaXNOYU4oY29tYm9bMF0pKSB7XG4gICAgICBpZiAoYWEgPiBiYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE9uZSBpcyBhIHN0cmluZywgb25lIGlzIGEgbnVtYmVyXG4gICAgaWYgKGlzTmFOKGNvbWJvWzFdKSkge1xuICAgICAgcmV0dXJuIGlzTmFOKGFuKSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIGFyZSBudW1iZXJzXG4gICAgaWYgKGFuID4gYm4pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYm4gPiBhbikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cblxuLy8gRXhwb3J0c1xuXG5jb25zdCBzb3J0aW5nRm5zID0ge1xuICBhbHBoYW51bWVyaWMsXG4gIGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUsXG4gIHRleHQsXG4gIHRleHRDYXNlU2Vuc2l0aXZlLFxuICBkYXRldGltZSxcbiAgYmFzaWNcbn07XG5cbi8vXG5cbmNvbnN0IFNvcnRpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nRm46ICdhdXRvJyxcbiAgICAgIHNvcnRVbmRlZmluZWQ6IDFcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblNvcnRpbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3NvcnRpbmcnLCB0YWJsZSksXG4gICAgICBpc011bHRpU29ydEV2ZW50OiBlID0+IHtcbiAgICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLnNsaWNlKDEwKTtcbiAgICAgIGxldCBpc1N0cmluZyA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCByb3cgb2YgZmlyc3RSb3dzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcm93ID09IG51bGwgPyB2b2lkIDAgOiByb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmRhdGV0aW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXNTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIGlmICh2YWx1ZS5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5hbHBoYW51bWVyaWM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMudGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3J0aW5nRm5zLmJhc2ljO1xuICAgIH07XG4gICAgY29sdW1uLmdldEF1dG9Tb3J0RGlyID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdhc2MnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdkZXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkc29ydGluLCBfdGFibGUkb3B0aW9ucyRzb3J0aW4yO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbikgPyBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA6IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbigpIDogKF90YWJsZSRvcHRpb25zJHNvcnRpbiA9IChfdGFibGUkb3B0aW9ucyRzb3J0aW4yID0gdGFibGUub3B0aW9ucy5zb3J0aW5nRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkc29ydGluMltjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRzb3J0aW4gOiBzb3J0aW5nRm5zW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID0gKGRlc2MsIG11bHRpKSA9PiB7XG4gICAgICAvLyBpZiAoY29sdW1uLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAvLyAgIGNvbHVtbi5jb2x1bW5zLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgIC8vICAgICBpZiAoYy5pZCkge1xuICAgICAgLy8gICAgICAgdGFibGUudG9nZ2xlQ29sdW1uU29ydGluZyhjLmlkLCB1bmRlZmluZWQsIG11bHRpIHx8ICEhaSlcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH0pXG4gICAgICAvLyAgIHJldHVyblxuICAgICAgLy8gfVxuXG4gICAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIG91dHNpZGUgb2YgdGFibGUuc2V0U29ydGluZyB0byBiZSBpbiBzeW5jIHdpdGggcmVyZW5kZXJcbiAgICAgIGNvbnN0IG5leHRTb3J0aW5nT3JkZXIgPSBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlcigpO1xuICAgICAgY29uc3QgaGFzTWFudWFsVmFsdWUgPSB0eXBlb2YgZGVzYyAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVzYyAhPT0gbnVsbDtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IHtcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3Rpbmcgc29ydGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdTb3J0aW5nID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBsZXQgbmV3U29ydGluZyA9IFtdO1xuXG4gICAgICAgIC8vIFdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdGhpcyBzb3J0IGFjdGlvbj9cbiAgICAgICAgbGV0IHNvcnRBY3Rpb247XG4gICAgICAgIGxldCBuZXh0RGVzYyA9IGhhc01hbnVhbFZhbHVlID8gZGVzYyA6IG5leHRTb3J0aW5nT3JkZXIgPT09ICdkZXNjJztcblxuICAgICAgICAvLyBNdWx0aS1tb2RlXG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQoKSAmJiBtdWx0aSkge1xuICAgICAgICAgIGlmIChleGlzdGluZ1NvcnRpbmcpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdhZGQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3JtYWwgbW9kZVxuICAgICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGV4aXN0aW5nSW5kZXggIT09IG9sZC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRvZ2dsZSBzdGF0ZXMgdGhhdCB3aWxsIHJlbW92ZSB0aGUgc29ydGluZ1xuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgXCJhY3R1YWxseVwiIHRvZ2dsaW5nIChub3QgYSBtYW51YWwgc2V0IHZhbHVlKSwgc2hvdWxkIHdlIHJlbW92ZSB0aGUgc29ydGluZz9cbiAgICAgICAgICBpZiAoIWhhc01hbnVhbFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJcyBvdXIgaW50ZW50aW9uIHRvIHJlbW92ZT9cbiAgICAgICAgICAgIGlmICghbmV4dFNvcnRpbmdPcmRlcikge1xuICAgICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlbW92ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRtYXhNdWw7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFsuLi5vbGQsIHtcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICAgIC8vIFRha2UgbGF0ZXN0IG4gY29sdW1uc1xuICAgICAgICAgIG5ld1NvcnRpbmcuc3BsaWNlKDAsIG5ld1NvcnRpbmcubGVuZ3RoIC0gKChfdGFibGUkb3B0aW9ucyRtYXhNdWwgPSB0YWJsZS5vcHRpb25zLm1heE11bHRpU29ydENvbENvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TXVsIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIFRoaXMgZmxpcHMgKG9yIHNldHMpIHRoZVxuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbe1xuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NvcnRpbmc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaXJzdFNvcnREaXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkc29yO1xuICAgICAgY29uc3Qgc29ydERlc2NGaXJzdCA9IChfcmVmID0gKF9jb2x1bW4kY29sdW1uRGVmJHNvciA9IGNvbHVtbi5jb2x1bW5EZWYuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJHNvciA6IHRhYmxlLm9wdGlvbnMuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9yZWYgOiBjb2x1bW4uZ2V0QXV0b1NvcnREaXIoKSA9PT0gJ2Rlc2MnO1xuICAgICAgcmV0dXJuIHNvcnREZXNjRmlyc3QgPyAnZGVzYycgOiAnYXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyID0gbXVsdGkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIGNvbnN0IGZpcnN0U29ydERpcmVjdGlvbiA9IGNvbHVtbi5nZXRGaXJzdFNvcnREaXIoKTtcbiAgICAgIGNvbnN0IGlzU29ydGVkID0gY29sdW1uLmdldElzU29ydGVkKCk7XG4gICAgICBpZiAoIWlzU29ydGVkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFNvcnREaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNTb3J0ZWQgIT09IGZpcnN0U29ydERpcmVjdGlvbiAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZ1JlbW92YWwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoXG4gICAgICAvLyBJZiBlbmFibGVTb3J0UmVtb3ZlLCBlbmFibGUgaW4gZ2VuZXJhbFxuICAgICAgbXVsdGkgPyAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSZW1vdmUpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSA6IHRydWUpIC8vIElmIG11bHRpLCBkb24ndCBhbGxvdyBpZiBlbmFibGVNdWx0aVJlbW92ZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU29ydGVkID09PSAnZGVzYycgPyAnYXNjJyA6ICdkZXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Tb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMztcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbk11bHRpU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmMiwgX2NvbHVtbiRjb2x1bW5EZWYkZW5hMjtcbiAgICAgIHJldHVybiAoX3JlZjIgPSAoX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX3JlZjIgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzU29ydGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTtcbiAgICAgIGNvbnN0IGNvbHVtblNvcnQgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgcmV0dXJuICFjb2x1bW5Tb3J0ID8gZmFsc2UgOiBjb2x1bW5Tb3J0LmRlc2MgPyAnZGVzYycgOiAnYXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTb3J0SW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHNvcnRpMiwgX3RhYmxlJGdldFN0YXRlJHNvcnRpMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkzID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLmNsZWFyU29ydGluZyA9ICgpID0+IHtcbiAgICAgIC8vY2xlYXIgc29ydGluZyBmb3IganVzdCAxIGNvbHVtblxuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4gb2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCA/IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpIDogW10pO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU29ydCA9IGNvbHVtbi5nZXRDYW5Tb3J0KCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGlmICghY2FuU29ydCkgcmV0dXJuO1xuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlU29ydGluZyh1bmRlZmluZWQsIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQoKSA/IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5pc011bHRpU29ydEV2ZW50KGUpIDogZmFsc2UpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFNvcnRpbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFNvcnRpbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRzID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFNvcnRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFNvcnRpbmcgfHwgIXRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBWaXNpYmlsaXR5ID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uVmlzaWJpbGl0eToge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uVmlzaWJpbGl0eScsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSA9IHZhbHVlID0+IHtcbiAgICAgIGlmIChjb2x1bW4uZ2V0Q2FuSGlkZSgpKSB7XG4gICAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIFtjb2x1bW4uaWRdOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAhY29sdW1uLmdldElzVmlzaWJsZSgpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Zpc2libGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtLCBfdGFibGUkZ2V0U3RhdGUkY29sdW0yO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTJbY29sdW1uLmlkXSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA6IHRydWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuSGlkZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSA9PSBudWxsIHx8IGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5KGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5WaXNpYmlsaXR5XSwgY2VsbHMgPT4ge1xuICAgICAgcmV0dXJuIGNlbGxzLmZpbHRlcihjZWxsID0+IGNlbGwuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJvdy5nZXRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuZ2V0TGVmdFZpc2libGVDZWxscygpLCByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzKCksIHJvdy5nZXRSaWdodFZpc2libGVDZWxscygpXSwgKGxlZnQsIGNlbnRlciwgcmlnaHQpID0+IFsuLi5sZWZ0LCAuLi5jZW50ZXIsIC4uLnJpZ2h0XSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldFZpc2libGVDZWxscycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBjb25zdCBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QgPSAoa2V5LCBnZXRDb2x1bW5zKSA9PiB7XG4gICAgICByZXR1cm4gbWVtbygoKSA9PiBbZ2V0Q29sdW1ucygpLCBnZXRDb2x1bW5zKCkuZmlsdGVyKGQgPT4gZC5nZXRJc1Zpc2libGUoKSkubWFwKGQgPT4gZC5pZCkuam9pbignXycpXSwgY29sdW1ucyA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBkLmdldElzVmlzaWJsZSgpKTtcbiAgICAgIH0sIHtcbiAgICAgICAga2V5LFxuICAgICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VmlzaWJsZUZsYXRDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlRmxhdENvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldENlbnRlclZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblZpc2liaWxpdHkgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblZpc2liaWxpdHkpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSA9IHZhbHVlID0+IHtcbiAgICAgIHZhciBfdmFsdWU7XG4gICAgICB2YWx1ZSA9IChfdmFsdWUgPSB2YWx1ZSkgIT0gbnVsbCA/IF92YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlKCk7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkucmVkdWNlKChvYmosIGNvbHVtbikgPT4gKHtcbiAgICAgICAgLi4ub2JqLFxuICAgICAgICBbY29sdW1uLmlkXTogIXZhbHVlID8gIShjb2x1bW4uZ2V0Q2FuSGlkZSAhPSBudWxsICYmIGNvbHVtbi5nZXRDYW5IaWRlKCkpIDogdmFsdWVcbiAgICAgIH0pLCB7fSkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSA9ICgpID0+ICF0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+ICEoY29sdW1uLmdldElzVmlzaWJsZSAhPSBudWxsICYmIGNvbHVtbi5nZXRJc1Zpc2libGUoKSkpO1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNWaXNpYmxlID0gKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBmZWF0dXJlcyA9IFtIZWFkZXJzLCBWaXNpYmlsaXR5LCBPcmRlcmluZywgUGlubmluZywgRmlsdGVycywgU29ydGluZywgR3JvdXBpbmcsIEV4cGFuZGluZywgUGFnaW5hdGlvbiwgUm93U2VsZWN0aW9uLCBDb2x1bW5TaXppbmddO1xuXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRpbml0aWFsU3RhdGU7XG4gIGlmIChvcHRpb25zLmRlYnVnQWxsIHx8IG9wdGlvbnMuZGVidWdUYWJsZSkge1xuICAgIGNvbnNvbGUuaW5mbygnQ3JlYXRpbmcgVGFibGUgSW5zdGFuY2UuLi4nKTtcbiAgfVxuICBsZXQgdGFibGUgPSB7XG4gICAgX2ZlYXR1cmVzOiBmZWF0dXJlc1xuICB9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXREZWZhdWx0T3B0aW9ucyh0YWJsZSkpO1xuICB9LCB7fSk7XG4gIGNvbnN0IG1lcmdlT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICAgIGlmICh0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH07XG4gIGNvbnN0IGNvcmVJbml0aWFsU3RhdGUgPSB7fTtcbiAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAuLi5jb3JlSW5pdGlhbFN0YXRlLFxuICAgIC4uLigoX29wdGlvbnMkaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGUpICE9IG51bGwgPyBfb3B0aW9ucyRpbml0aWFsU3RhdGUgOiB7fSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgdmFyIF9mZWF0dXJlJGdldEluaXRpYWxTdDtcbiAgICBpbml0aWFsU3RhdGUgPSAoX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0ID0gZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSkpICE9IG51bGwgPyBfZmVhdHVyZSRnZXRJbml0aWFsU3QgOiBpbml0aWFsU3RhdGU7XG4gIH0pO1xuICBjb25zdCBxdWV1ZWQgPSBbXTtcbiAgbGV0IHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcbiAgY29uc3QgY29yZUluc3RhbmNlID0ge1xuICAgIF9mZWF0dXJlczogZmVhdHVyZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgX3F1ZXVlOiBjYiA9PiB7XG4gICAgICBxdWV1ZWQucHVzaChjYik7XG4gICAgICBpZiAoIXF1ZXVlZFRpbWVvdXQpIHtcbiAgICAgICAgcXVldWVkVGltZW91dCA9IHRydWU7XG5cbiAgICAgICAgLy8gU2NoZWR1bGUgYSBtaWNyb3Rhc2sgdG8gcnVuIHRoZSBxdWV1ZWQgY2FsbGJhY2tzIGFmdGVyXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgKHJlbmRlciwgZXRjKSBoYXMgZmluaXNoZWQuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHdoaWxlIChxdWV1ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBxdWV1ZWQuc2hpZnQoKSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgdGFibGUuc2V0U3RhdGUodGFibGUuaW5pdGlhbFN0YXRlKTtcbiAgICB9LFxuICAgIHNldE9wdGlvbnM6IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgdGFibGUub3B0aW9ucyk7XG4gICAgICB0YWJsZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2V0U3RhdGU6ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLnN0YXRlO1xuICAgIH0sXG4gICAgc2V0U3RhdGU6IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH0sXG4gICAgX2dldFJvd0lkOiAocm93LCBpbmRleCwgcGFyZW50KSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93O1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRnZXRSb3cgPSB0YWJsZS5vcHRpb25zLmdldFJvd0lkID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0lkKHJvdywgaW5kZXgsIHBhcmVudCkpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRSb3cgOiBgJHtwYXJlbnQgPyBbcGFyZW50LmlkLCBpbmRleF0uam9pbignLicpIDogaW5kZXh9YDtcbiAgICB9LFxuICAgIGdldENvcmVSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldENvcmVSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldENvcmVSb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgLy8gVGhlIGZpbmFsIGNhbGxzIHN0YXJ0IGF0IHRoZSBib3R0b20gb2YgdGhlIG1vZGVsLFxuICAgIC8vIGV4cGFuZGVkIHJvd3MsIHdoaWNoIHRoZW4gd29yayB0aGVpciB3YXkgdXBcblxuICAgIGdldFJvd01vZGVsOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgfSxcbiAgICBnZXRSb3c6IChpZCwgc2VhcmNoQWxsKSA9PiB7XG4gICAgICBjb25zdCByb3cgPSAoc2VhcmNoQWxsID8gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkgOiB0YWJsZS5nZXRSb3dNb2RlbCgpKS5yb3dzQnlJZFtpZF07XG4gICAgICBpZiAoIXJvdykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93IGV4cGVjdGVkIGFuIElELCBidXQgZ290ICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93O1xuICAgIH0sXG4gICAgX2dldERlZmF1bHRDb2x1bW5EZWY6IG1lbW8oKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGVmYXVsdENvbHVtbl0sIGRlZmF1bHRDb2x1bW4gPT4ge1xuICAgICAgdmFyIF9kZWZhdWx0Q29sdW1uO1xuICAgICAgZGVmYXVsdENvbHVtbiA9IChfZGVmYXVsdENvbHVtbiA9IGRlZmF1bHRDb2x1bW4pICE9IG51bGwgPyBfZGVmYXVsdENvbHVtbiA6IHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiBwcm9wcyA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSBwcm9wcy5oZWFkZXIuY29sdW1uLmNvbHVtbkRlZjtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4pIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZvb3RlcjogcHJvcHMgPT4gcHJvcHMuaGVhZGVyLmNvbHVtbi5pZCxcbiAgICAgICAgY2VsbDogcHJvcHMgPT4ge1xuICAgICAgICAgIHZhciBfcHJvcHMkcmVuZGVyVmFsdWUkdG8sIF9wcm9wcyRyZW5kZXJWYWx1ZTtcbiAgICAgICAgICByZXR1cm4gKF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA9IChfcHJvcHMkcmVuZGVyVmFsdWUgPSBwcm9wcy5yZW5kZXJWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfcHJvcHMkcmVuZGVyVmFsdWUkdG8gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAuLi50YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZiA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmKCkpO1xuICAgICAgICB9LCB7fSksXG4gICAgICAgIC4uLmRlZmF1bHRDb2x1bW5cbiAgICAgIH07XG4gICAgfSwge1xuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9LFxuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RGVmYXVsdENvbHVtbkRlZidcbiAgICB9KSxcbiAgICBfZ2V0Q29sdW1uRGVmczogKCkgPT4gdGFibGUub3B0aW9ucy5jb2x1bW5zLFxuICAgIGdldEFsbENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLl9nZXRDb2x1bW5EZWZzKCldLCBjb2x1bW5EZWZzID0+IHtcbiAgICAgIGNvbnN0IHJlY3Vyc2VDb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbkRlZnMsIHBhcmVudCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbkRlZnMubWFwKGNvbHVtbkRlZiA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gY3JlYXRlQ29sdW1uKHRhYmxlLCBjb2x1bW5EZWYsIGRlcHRoLCBwYXJlbnQpO1xuICAgICAgICAgIGNvbnN0IGdyb3VwaW5nQ29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgICAgICAgIGNvbHVtbi5jb2x1bW5zID0gZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucyA/IHJlY3Vyc2VDb2x1bW5zKGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMsIGNvbHVtbiwgZGVwdGggKyAxKSA6IFtdO1xuICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZWN1cnNlQ29sdW1ucyhjb2x1bW5EZWZzKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRBbGxDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGdldEFsbEZsYXRDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCldLCBhbGxDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRGbGF0Q29sdW1ucygpO1xuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0QWxsRmxhdENvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSksXG4gICAgX2dldEFsbEZsYXRDb2x1bW5zQnlJZDogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKV0sIGZsYXRDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBmbGF0Q29sdW1ucy5yZWR1Y2UoKGFjYywgY29sdW1uKSA9PiB7XG4gICAgICAgIGFjY1tjb2x1bW4uaWRdID0gY29sdW1uO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEFsbEZsYXRDb2x1bW5zQnlJZCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNDtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTQgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBnZXRBbGxMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIChhbGxDb2x1bW5zLCBvcmRlckNvbHVtbnMpID0+IHtcbiAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpO1xuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucyk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0QWxsTGVhZkNvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTU7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1IDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSksXG4gICAgZ2V0Q29sdW1uOiBjb2x1bW5JZCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5fZ2V0QWxsRmxhdENvbHVtbnNCeUlkKClbY29sdW1uSWRdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbHVtbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbVGFibGVdIENvbHVtbiB3aXRoIGlkICcke2NvbHVtbklkfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih0YWJsZSwgY29yZUluc3RhbmNlKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2luZGV4XTtcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUodGFibGUpO1xuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbklkKSB7XG4gIGNvbnN0IGdldFJlbmRlclZhbHVlID0gKCkgPT4ge1xuICAgIHZhciBfY2VsbCRnZXRWYWx1ZTtcbiAgICByZXR1cm4gKF9jZWxsJGdldFZhbHVlID0gY2VsbC5nZXRWYWx1ZSgpKSAhPSBudWxsID8gX2NlbGwkZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XG4gIH07XG4gIGNvbnN0IGNlbGwgPSB7XG4gICAgaWQ6IGAke3Jvdy5pZH1fJHtjb2x1bW4uaWR9YCxcbiAgICByb3csXG4gICAgY29sdW1uLFxuICAgIGdldFZhbHVlOiAoKSA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpLFxuICAgIHJlbmRlclZhbHVlOiBnZXRSZW5kZXJWYWx1ZSxcbiAgICBnZXRDb250ZXh0OiBtZW1vKCgpID0+IFt0YWJsZSwgY29sdW1uLCByb3csIGNlbGxdLCAodGFibGUsIGNvbHVtbiwgcm93LCBjZWxsKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBjb2x1bW4sXG4gICAgICByb3csXG4gICAgICBjZWxsOiBjZWxsLFxuICAgICAgZ2V0VmFsdWU6IGNlbGwuZ2V0VmFsdWUsXG4gICAgICByZW5kZXJWYWx1ZTogY2VsbC5yZW5kZXJWYWx1ZVxuICAgIH0pLCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdjZWxsLmdldENvbnRleHQnLFxuICAgICAgZGVidWc6ICgpID0+IHRhYmxlLm9wdGlvbnMuZGVidWdBbGxcbiAgICB9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNlbGwgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNlbGwoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKTtcbiAgfSwge30pO1xuICByZXR1cm4gY2VsbDtcbn1cblxuY29uc3QgY3JlYXRlUm93ID0gKHRhYmxlLCBpZCwgb3JpZ2luYWwsIHJvd0luZGV4LCBkZXB0aCwgc3ViUm93cywgcGFyZW50SWQpID0+IHtcbiAgbGV0IHJvdyA9IHtcbiAgICBpZCxcbiAgICBpbmRleDogcm93SW5kZXgsXG4gICAgb3JpZ2luYWwsXG4gICAgZGVwdGgsXG4gICAgcGFyZW50SWQsXG4gICAgX3ZhbHVlc0NhY2hlOiB7fSxcbiAgICBfdW5pcXVlVmFsdWVzQ2FjaGU6IHt9LFxuICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uYWNjZXNzb3JGbihyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIGdldFVuaXF1ZVZhbHVlczogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uYWNjZXNzb3JGbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBbcm93LmdldFZhbHVlKGNvbHVtbklkKV07XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XG4gICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfSxcbiAgICByZW5kZXJWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgdmFyIF9yb3ckZ2V0VmFsdWU7XG4gICAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX3JvdyRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgICB9LFxuICAgIHN1YlJvd3M6IHN1YlJvd3MgIT0gbnVsbCA/IHN1YlJvd3MgOiBbXSxcbiAgICBnZXRMZWFmUm93czogKCkgPT4gZmxhdHRlbkJ5KHJvdy5zdWJSb3dzLCBkID0+IGQuc3ViUm93cyksXG4gICAgZ2V0UGFyZW50Um93OiAoKSA9PiByb3cucGFyZW50SWQgPyB0YWJsZS5nZXRSb3cocm93LnBhcmVudElkLCB0cnVlKSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQYXJlbnRSb3dzOiAoKSA9PiB7XG4gICAgICBsZXQgcGFyZW50Um93cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3cgPSBjdXJyZW50Um93LmdldFBhcmVudFJvdygpO1xuICAgICAgICBpZiAoIXBhcmVudFJvdykgYnJlYWs7XG4gICAgICAgIHBhcmVudFJvd3MucHVzaChwYXJlbnRSb3cpO1xuICAgICAgICBjdXJyZW50Um93ID0gcGFyZW50Um93O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFJvd3MucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgZ2V0QWxsQ2VsbHM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCldLCBsZWFmQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uLmlkKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ3Jvdy5nZXRBbGxDZWxscycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkOiBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKV0sIGFsbENlbGxzID0+IHtcbiAgICAgIHJldHVybiBhbGxDZWxscy5yZWR1Y2UoKGFjYywgY2VsbCkgPT4ge1xuICAgICAgICBhY2NbY2VsbC5jb2x1bW4uaWRdID0gY2VsbDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ3Jvdy5nZXRBbGxDZWxsc0J5Q29sdW1uSWQnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSlcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2ldO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93KHJvdywgdGFibGUpO1xuICB9XG4gIHJldHVybiByb3c7XG59O1xuXG4vLyB0eXBlIFBlcnNvbiA9IHtcbi8vICAgZmlyc3ROYW1lOiBzdHJpbmdcbi8vICAgbGFzdE5hbWU6IHN0cmluZ1xuLy8gICBhZ2U6IG51bWJlclxuLy8gICB2aXNpdHM6IG51bWJlclxuLy8gICBzdGF0dXM6IHN0cmluZ1xuLy8gICBwcm9ncmVzczogbnVtYmVyXG4vLyAgIGNyZWF0ZWRBdDogRGF0ZVxuLy8gICBuZXN0ZWQ6IHtcbi8vICAgICBmb286IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgYmFyOiAnYmFyJ1xuLy8gICAgICAgfVxuLy8gICAgIF1cbi8vICAgICBiYXI6IHsgc3ViQmFyOiBib29sZWFuIH1bXVxuLy8gICAgIGJhejoge1xuLy8gICAgICAgZm9vOiAnZm9vJ1xuLy8gICAgICAgYmFyOiB7XG4vLyAgICAgICAgIGJhejogJ2Jheidcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuLy8gY29uc3QgdGVzdDogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuZm9vLjAuYmFyJ1xuLy8gY29uc3QgdGVzdDI6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmJhcidcblxuLy8gY29uc3QgaGVscGVyID0gY3JlYXRlQ29sdW1uSGVscGVyPFBlcnNvbj4oKVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28nLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vLjAuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uSGVscGVyKCkge1xuICByZXR1cm4ge1xuICAgIGFjY2Vzc29yOiAoYWNjZXNzb3IsIGNvbHVtbikgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvckZuOiBhY2Nlc3NvclxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvcktleTogYWNjZXNzb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBkaXNwbGF5OiBjb2x1bW4gPT4gY29sdW1uLFxuICAgIGdyb3VwOiBjb2x1bW4gPT4gY29sdW1uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvcmVSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGF0YV0sIGRhdGEgPT4ge1xuICAgIGNvbnN0IHJvd01vZGVsID0ge1xuICAgICAgcm93czogW10sXG4gICAgICBmbGF0Um93czogW10sXG4gICAgICByb3dzQnlJZDoge31cbiAgICB9O1xuICAgIGNvbnN0IGFjY2Vzc1Jvd3MgPSBmdW5jdGlvbiAob3JpZ2luYWxSb3dzLCBkZXB0aCwgcGFyZW50Um93KSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIGV4cGVuc2l2ZSBjaGVjayBhdCBzY2FsZSwgc28gd2Ugc2hvdWxkIG1vdmUgaXQgc29tZXdoZXJlIGVsc2UsIGJ1dCB3aGVyZT9cbiAgICAgICAgLy8gaWYgKCFpZCkge1xuICAgICAgICAvLyAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvd0lkIGV4cGVjdGVkIGFuIElELCBidXQgZ290ICR7aWR9YClcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBNYWtlIHRoZSByb3dcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCB0YWJsZS5fZ2V0Um93SWQob3JpZ2luYWxSb3dzW2ldLCBpLCBwYXJlbnRSb3cpLCBvcmlnaW5hbFJvd3NbaV0sIGksIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudFJvdyA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50Um93LmlkKTtcblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBpbiBhIGZsYXQgYXJyYXlcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGJ5IGl0cyBJRFxuICAgICAgICByb3dNb2RlbC5yb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAvLyBQdXNoIHRhYmxlIHJvdyBpbnRvIHBhcmVudFxuICAgICAgICByb3dzLnB1c2gocm93KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcbiAgICAgICAgaWYgKHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cykge1xuICAgICAgICAgIHZhciBfcm93JG9yaWdpbmFsU3ViUm93cztcbiAgICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzID0gdGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKG9yaWdpbmFsUm93c1tpXSwgaSk7XG5cbiAgICAgICAgICAvLyBUaGVuIHJlY3Vyc2l2ZWx5IGFjY2VzcyB0aGVtXG4gICAgICAgICAgaWYgKChfcm93JG9yaWdpbmFsU3ViUm93cyA9IHJvdy5vcmlnaW5hbFN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRvcmlnaW5hbFN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByb3cuc3ViUm93cyA9IGFjY2Vzc1Jvd3Mocm93Lm9yaWdpbmFsU3ViUm93cywgZGVwdGggKyAxLCByb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICByb3dNb2RlbC5yb3dzID0gYWNjZXNzUm93cyhkYXRhKTtcbiAgICByZXR1cm4gcm93TW9kZWw7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclJvd3Mocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpIHtcbiAgaWYgKHRhYmxlLm9wdGlvbnMuZmlsdGVyRnJvbUxlYWZSb3dzKSB7XG4gICAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyUm93TW9kZWxGcm9tUm9vdChyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcbiAgdmFyIF90YWJsZSRvcHRpb25zJG1heExlYTtcbiAgY29uc3QgbmV3RmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gIGNvbnN0IG1heERlcHRoID0gKF90YWJsZSRvcHRpb25zJG1heExlYSA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhIDogMTAwO1xuICBjb25zdCByZWN1cnNlRmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzVG9GaWx0ZXIsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMDtcbiAgICB9XG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgLy8gRmlsdGVyIGZyb20gY2hpbGRyZW4gdXAgZmlyc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIGxldCByb3cgPSByb3dzVG9GaWx0ZXJbaV07XG4gICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xuICAgICAgbmV3Um93LmNvbHVtbkZpbHRlcnMgPSByb3cuY29sdW1uRmlsdGVycztcbiAgICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpICYmICFuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpIHx8IG5ld1Jvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tUm9vdChyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcbiAgdmFyIF90YWJsZSRvcHRpb25zJG1heExlYTI7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEyID0gdGFibGUub3B0aW9ucy5tYXhMZWFmUm93RmlsdGVyRGVwdGgpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhMZWEyIDogMTAwO1xuXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuICBjb25zdCByZWN1cnNlRmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzVG9GaWx0ZXIsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMDtcbiAgICB9XG4gICAgLy8gRmlsdGVyIGZyb20gcGFyZW50cyBkb3dud2FyZCBmaXJzdFxuXG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgLy8gQXBwbHkgdGhlIGZpbHRlciB0byBhbnkgc3ViUm93c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93c1RvRmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgcGFzcyA9IGZpbHRlclJvdyhyb3cpO1xuICAgICAgaWYgKHBhc3MpIHtcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93czI7XG4gICAgICAgIGlmICgoX3JvdyRzdWJSb3dzMiA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czIubGVuZ3RoICYmIGRlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xuICAgICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XG4gICAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICB9XG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlRmlsdGVyUm93cyhyb3dzVG9GaWx0ZXIpLFxuICAgIGZsYXRSb3dzOiBuZXdGaWx0ZXJlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdGaWx0ZXJlZFJvd3NCeUlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZpbHRlcmVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXJdLCAocm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVycyA9IHt9O1xuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZENvbHVtbkZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCByZXNvbHZlZEdsb2JhbEZpbHRlcnMgPSBbXTtcbiAgICAoY29sdW1uRmlsdGVycyAhPSBudWxsID8gY29sdW1uRmlsdGVycyA6IFtdKS5mb3JFYWNoKGQgPT4ge1xuICAgICAgdmFyIF9maWx0ZXJGbiRyZXNvbHZlRmlsdDtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihkLmlkKTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICBpZiAoIWZpbHRlckZuKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBhIHZhbGlkICdjb2x1bW4uZmlsdGVyRm4nIGZvciBjb2x1bW4gd2l0aCB0aGUgSUQ6ICR7Y29sdW1uLmlkfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbHVtbkZpbHRlcnMucHVzaCh7XG4gICAgICAgIGlkOiBkLmlkLFxuICAgICAgICBmaWx0ZXJGbixcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA9IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGQudmFsdWUpKSAhPSBudWxsID8gX2ZpbHRlckZuJHJlc29sdmVGaWx0IDogZC52YWx1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IGNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCk7XG4gICAgY29uc3QgZ2xvYmFsRmlsdGVyRm4gPSB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbigpO1xuICAgIGNvbnN0IGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldENhbkdsb2JhbEZpbHRlcigpKTtcbiAgICBpZiAoZ2xvYmFsRmlsdGVyICYmIGdsb2JhbEZpbHRlckZuICYmIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBmaWx0ZXJhYmxlSWRzLnB1c2goJ19fZ2xvYmFsX18nKTtcbiAgICAgIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX2dsb2JhbEZpbHRlckZuJHJlc29sO1xuICAgICAgICByZXNvbHZlZEdsb2JhbEZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICBmaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm4sXG4gICAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA9IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGdsb2JhbEZpbHRlcikpICE9IG51bGwgPyBfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgOiBnbG9iYWxGaWx0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRDb2x1bW5GaWx0ZXI7XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxGaWx0ZXI7XG5cbiAgICAvLyBGbGFnIHRoZSBwcmVmaWx0ZXJlZCByb3cgbW9kZWwgd2l0aCBlYWNoIGZpbHRlciBzdGF0ZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHJvd01vZGVsLmZsYXRSb3dzW2pdO1xuICAgICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgIGlmIChyZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudENvbHVtbkZpbHRlciA9IHJlc29sdmVkQ29sdW1uRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuaWQ7XG5cbiAgICAgICAgICAvLyBUYWcgdGhlIHJvdyB3aXRoIHRoZSBjb2x1bW4gZmlsdGVyIHN0YXRlXG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNbaWRdID0gY3VycmVudENvbHVtbkZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50Q29sdW1uRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudEdsb2JhbEZpbHRlciA9IHJlc29sdmVkR2xvYmFsRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRHbG9iYWxGaWx0ZXIuaWQ7XG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgZmlyc3QgdHJ1dGh5IGdsb2JhbCBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICBpZiAoY3VycmVudEdsb2JhbEZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50R2xvYmFsRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fICE9PSB0cnVlKSB7XG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIEZpbHRlciBmaW5hbCByb3dzIHVzaW5nIGFsbCBvZiB0aGUgYWN0aXZlIGZpbHRlcnNcbiAgICByZXR1cm4gZmlsdGVyUm93cyhyb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmlsdGVyZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlciwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHByZVJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXByZVJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICByZXR1cm4gcHJlUm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSBbLi4uY29sdW1uRmlsdGVycy5tYXAoZCA9PiBkLmlkKS5maWx0ZXIoZCA9PiBkICE9PSBjb2x1bW5JZCksIGdsb2JhbEZpbHRlciA/ICdfX2dsb2JhbF9fJyA6IHVuZGVmaW5lZF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsdGVyUm93cyhwcmVSb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmFjZXRlZFJvd01vZGVsXycgKyBjb2x1bW5JZCxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xuICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgIHJldHVybiBbKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwoKV07XG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiBuZXcgTWFwKCk7XG4gICAgbGV0IGZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmIChmYWNldGVkVW5pcXVlVmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkO1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAoKF9mYWNldGVkVW5pcXVlVmFsdWVzJCA9IGZhY2V0ZWRVbmlxdWVWYWx1ZXMuZ2V0KHZhbHVlKSkgIT0gbnVsbCA/IF9mYWNldGVkVW5pcXVlVmFsdWVzJCA6IDApICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkVW5pcXVlVmFsdWVzO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlc18nICsgY29sdW1uSWQsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIHZhciBfZmFjZXRlZFJvd01vZGVsJGZsYXQ7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IChfZmFjZXRlZFJvd01vZGVsJGZsYXQgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZmFjZXRlZFJvd01vZGVsJGZsYXQuZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZmFjZXRlZE1pbk1heFZhbHVlcyA9IFtmaXJzdFZhbHVlLCBmaXJzdFZhbHVlXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgZmFjZXRlZE1pbk1heFZhbHVlc1swXSkge1xuICAgICAgICAgIGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMV0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0ZWRNaW5NYXhWYWx1ZXM7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRGYWNldGVkTWluTWF4VmFsdWVzXycgKyBjb2x1bW5JZCxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcsIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCldLCAoc29ydGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoc29ydGluZyAhPSBudWxsICYmIHNvcnRpbmcubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBzb3J0aW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmc7XG4gICAgY29uc3Qgc29ydGVkRmxhdFJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBvdXQgc29ydGluZ3MgdGhhdCBjb3JyZXNwb25kIHRvIG5vbiBleGlzdGluZyBjb2x1bW5zXG4gICAgY29uc3QgYXZhaWxhYmxlU29ydGluZyA9IHNvcnRpbmdTdGF0ZS5maWx0ZXIoc29ydCA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihzb3J0LmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbHVtbkluZm9CeUlkID0ge307XG4gICAgYXZhaWxhYmxlU29ydGluZy5mb3JFYWNoKHNvcnRFbnRyeSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydEVudHJ5LmlkKTtcbiAgICAgIGlmICghY29sdW1uKSByZXR1cm47XG4gICAgICBjb2x1bW5JbmZvQnlJZFtzb3J0RW50cnkuaWRdID0ge1xuICAgICAgICBzb3J0VW5kZWZpbmVkOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRVbmRlZmluZWQsXG4gICAgICAgIGludmVydFNvcnRpbmc6IGNvbHVtbi5jb2x1bW5EZWYuaW52ZXJ0U29ydGluZyxcbiAgICAgICAgc29ydGluZ0ZuOiBjb2x1bW4uZ2V0U29ydGluZ0ZuKClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc29ydERhdGEgPSByb3dzID0+IHtcbiAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHBlcmZvcm0gYSBzdGFibGUgc29ydGluZyB1c2luZyB0aGUgcm93IGluZGV4XG4gICAgICAvLyBpZiBuZWVkZWQuXG4gICAgICBjb25zdCBzb3J0ZWREYXRhID0gcm93cy5tYXAocm93ID0+ICh7XG4gICAgICAgIC4uLnJvd1xuICAgICAgfSkpO1xuICAgICAgc29ydGVkRGF0YS5zb3J0KChyb3dBLCByb3dCKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXZhaWxhYmxlU29ydGluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBfc29ydEVudHJ5JGRlc2M7XG4gICAgICAgICAgY29uc3Qgc29ydEVudHJ5ID0gYXZhaWxhYmxlU29ydGluZ1tpXTtcbiAgICAgICAgICBjb25zdCBjb2x1bW5JbmZvID0gY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXTtcbiAgICAgICAgICBjb25zdCBpc0Rlc2MgPSAoX3NvcnRFbnRyeSRkZXNjID0gc29ydEVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBzb3J0RW50cnkuZGVzYykgIT0gbnVsbCA/IF9zb3J0RW50cnkkZGVzYyA6IGZhbHNlO1xuICAgICAgICAgIGxldCBzb3J0SW50ID0gMDtcblxuICAgICAgICAgIC8vIEFsbCBzb3J0aW5nIGludHMgc2hvdWxkIGFsd2F5cyByZXR1cm4gaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgaWYgKGNvbHVtbkluZm8uc29ydFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgYVZhbHVlID0gcm93QS5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xuICAgICAgICAgICAgY29uc3QgYlZhbHVlID0gcm93Qi5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xuICAgICAgICAgICAgY29uc3QgYVVuZGVmaW5lZCA9IGFWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgYlVuZGVmaW5lZCA9IGJWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFVbmRlZmluZWQgfHwgYlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzb3J0SW50ID0gYVVuZGVmaW5lZCAmJiBiVW5kZWZpbmVkID8gMCA6IGFVbmRlZmluZWQgPyBjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQgOiAtY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc29ydEludCA9PT0gMCkge1xuICAgICAgICAgICAgc29ydEludCA9IGNvbHVtbkluZm8uc29ydGluZ0ZuKHJvd0EsIHJvd0IsIHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgc29ydGluZyBpcyBub24temVybywgdGFrZSBjYXJlIG9mIGRlc2MgYW5kIGludmVyc2lvblxuICAgICAgICAgIGlmIChzb3J0SW50ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNEZXNjKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sdW1uSW5mby5pbnZlcnRTb3J0aW5nKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydEludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd0EuaW5kZXggLSByb3dCLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzdWItcm93cywgc29ydCB0aGVtXG4gICAgICBzb3J0ZWREYXRhLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgICAgc29ydGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3cuc3ViUm93cyA9IHNvcnREYXRhKHJvdy5zdWJSb3dzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydGVkRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBzb3J0RGF0YShyb3dNb2RlbC5yb3dzKSxcbiAgICAgIGZsYXRSb3dzOiBzb3J0ZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICAgIH07XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRTb3J0ZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpXSwgKGdyb3VwaW5nLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIWdyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciB0aGUgZ3JvdXBpbmcgbGlzdCBkb3duIHRvIGNvbHVtbnMgdGhhdCBleGlzdFxuICAgIGNvbnN0IGV4aXN0aW5nR3JvdXBpbmcgPSBncm91cGluZy5maWx0ZXIoY29sdW1uSWQgPT4gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSk7XG4gICAgY29uc3QgZ3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgY29uc3QgZ3JvdXBlZFJvd3NCeUlkID0ge307XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcbiAgICAvLyBjb25zdCBub25Hcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGdyb3VwIHRoZSBkYXRhXG4gICAgY29uc3QgZ3JvdXBVcFJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgLy8gR3JvdXBpbmcgZGVwdGggaGFzIGJlZW4gYmVlbiBtZXRcbiAgICAgIC8vIFN0b3AgZ3JvdXBpbmcgYW5kIHNpbXBseSByZXdyaXRlIHRoZCBkZXB0aCBhbmQgcm93IHJlbGF0aW9uc2hpcHNcbiAgICAgIGlmIChkZXB0aCA+PSBleGlzdGluZ0dyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICByb3cuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIGlmIChyb3cuc3ViUm93cykge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93LnN1YlJvd3MsIGRlcHRoICsgMSwgcm93LmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW5JZCA9IGV4aXN0aW5nR3JvdXBpbmdbZGVwdGhdO1xuXG4gICAgICAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxuICAgICAgY29uc3Qgcm93R3JvdXBzTWFwID0gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCk7XG5cbiAgICAgIC8vIFBlZm9ybSBhZ2dyZWdhdGlvbnMgZm9yIGVhY2ggZ3JvdXBcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWRHcm91cGVkUm93cyA9IEFycmF5LmZyb20ocm93R3JvdXBzTWFwLmVudHJpZXMoKSkubWFwKChfcmVmLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgW2dyb3VwaW5nVmFsdWUsIGdyb3VwZWRSb3dzXSA9IF9yZWY7XG4gICAgICAgIGxldCBpZCA9IGAke2NvbHVtbklkfToke2dyb3VwaW5nVmFsdWV9YDtcbiAgICAgICAgaWQgPSBwYXJlbnRJZCA/IGAke3BhcmVudElkfT4ke2lkfWAgOiBpZDtcblxuICAgICAgICAvLyBGaXJzdCwgUmVjdXJzZSB0byBncm91cCBzdWIgcm93cyBiZWZvcmUgYWdncmVnYXRpb25cbiAgICAgICAgY29uc3Qgc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShncm91cGVkUm93cywgZGVwdGggKyAxLCBpZCk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgbGVhZiByb3dzIG9mIHRoZSByb3dzIGluIHRoaXMgZ3JvdXBcbiAgICAgICAgY29uc3QgbGVhZlJvd3MgPSBkZXB0aCA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgcm93ID0+IHJvdy5zdWJSb3dzKSA6IGdyb3VwZWRSb3dzO1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIGlkLCBsZWFmUm93c1swXS5vcmlnaW5hbCwgaW5kZXgsIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudElkKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHtcbiAgICAgICAgICBncm91cGluZ0NvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgICBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgIHN1YlJvd3MsXG4gICAgICAgICAgbGVhZlJvd3MsXG4gICAgICAgICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cGluZ1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXBpbmcuaW5jbHVkZXMoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFJvd3NbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dyb3VwZWRSb3dzJDAkZ2V0VmFsO1xuICAgICAgICAgICAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gKF9ncm91cGVkUm93cyQwJGdldFZhbCA9IGdyb3VwZWRSb3dzWzBdLmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9ncm91cGVkUm93cyQwJGdldFZhbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGVGbiA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldEFnZ3JlZ2F0aW9uRm4oKTtcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xuICAgICAgICAgICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gYWdncmVnYXRlRm4oY29sdW1uSWQsIGxlYWZSb3dzLCBncm91cGVkUm93cyk7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cztcbiAgICB9O1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd01vZGVsLnJvd3MsIDApO1xuICAgIGdyb3VwZWRSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIC8vICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIC8vICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZFxuICAgIH07XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRHcm91cGVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCgpO1xuICAgICAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCkge1xuICBjb25zdCBncm91cE1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHJvd3MucmVkdWNlKChtYXAsIHJvdykgPT4ge1xuICAgIGNvbnN0IHJlc0tleSA9IGAke3Jvdy5nZXRHcm91cGluZ1ZhbHVlKGNvbHVtbklkKX1gO1xuICAgIGNvbnN0IHByZXZpb3VzID0gbWFwLmdldChyZXNLZXkpO1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIG1hcC5zZXQocmVzS2V5LCBbcm93XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzLnB1c2gocm93KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgZ3JvdXBNYXApO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCwgdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpLCB0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzXSwgKGV4cGFuZGVkLCByb3dNb2RlbCwgcGFnaW5hdGVFeHBhbmRlZFJvd3MpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8IGV4cGFuZGVkICE9PSB0cnVlICYmICFPYmplY3Qua2V5cyhleHBhbmRlZCAhPSBudWxsID8gZXhwYW5kZWQgOiB7fSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGlmICghcGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIC8vIE9ubHkgZXhwYW5kIHJvd3MgYXQgdGhpcyBwb2ludCBpZiB0aGV5IGFyZSBiZWluZyBwYWdpbmF0ZWRcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZFJvd3Mocm93TW9kZWwpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RXhwYW5kZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93TW9kZWwpIHtcbiAgY29uc3QgZXhwYW5kZWRSb3dzID0gW107XG4gIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0SXNFeHBhbmRlZCgpKSB7XG4gICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgfVxuICB9O1xuICByb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgZmxhdFJvd3M6IHJvd01vZGVsLmZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYWdpbmF0aW9uUm93TW9kZWwob3B0cykge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyA/IHVuZGVmaW5lZCA6IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRdLCAocGFnaW5hdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VTaXplLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHBhZ2luYXRpb247XG4gICAgbGV0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkXG4gICAgfSA9IHJvd01vZGVsO1xuICAgIGNvbnN0IHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgIGNvbnN0IHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyBwYWdlU2l6ZTtcbiAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgIGxldCBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgICBpZiAoIXRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0gZXhwYW5kUm93cyh7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0ge1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH07XG4gICAgfVxuICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW107XG4gICAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgIGlmIChyb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFnaW5hdGVkUm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJvd01vZGVsO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UGFnaW5hdGlvblJvd01vZGVsJyxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb2x1bW5TaXppbmcsIEV4cGFuZGluZywgRmlsdGVycywgR3JvdXBpbmcsIEhlYWRlcnMsIE9yZGVyaW5nLCBQYWdpbmF0aW9uLCBQaW5uaW5nLCBSb3dTZWxlY3Rpb24sIFNvcnRpbmcsIFZpc2liaWxpdHksIGFnZ3JlZ2F0aW9uRm5zLCBidWlsZEhlYWRlckdyb3VwcywgY3JlYXRlQ2VsbCwgY3JlYXRlQ29sdW1uLCBjcmVhdGVDb2x1bW5IZWxwZXIsIGNyZWF0ZVJvdywgY3JlYXRlVGFibGUsIGRlZmF1bHRDb2x1bW5TaXppbmcsIGV4cGFuZFJvd3MsIGZpbHRlckZucywgZmxhdHRlbkJ5LCBmdW5jdGlvbmFsVXBkYXRlLCBnZXRDb3JlUm93TW9kZWwsIGdldEV4cGFuZGVkUm93TW9kZWwsIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMsIGdldEZhY2V0ZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcywgZ2V0RmlsdGVyZWRSb3dNb2RlbCwgZ2V0R3JvdXBlZFJvd01vZGVsLCBnZXRQYWdpbmF0aW9uUm93TW9kZWwsIGdldFNvcnRlZFJvd01vZGVsLCBpc0Z1bmN0aW9uLCBpc051bWJlckFycmF5LCBpc1Jvd1NlbGVjdGVkLCBpc1N1YlJvd1NlbGVjdGVkLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vLCBub29wLCBvcmRlckNvbHVtbnMsIHBhc3NpdmVFdmVudFN1cHBvcnRlZCwgcmVTcGxpdEFscGhhTnVtZXJpYywgc2VsZWN0Um93c0ZuLCBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyLCBzb3J0aW5nRm5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiZnVuY3Rpb25hbFVwZGF0ZSIsInVwZGF0ZXIiLCJpbnB1dCIsIm5vb3AiLCJtYWtlU3RhdGVVcGRhdGVyIiwia2V5IiwiaW5zdGFuY2UiLCJzZXRTdGF0ZSIsIm9sZCIsImlzRnVuY3Rpb24iLCJkIiwiRnVuY3Rpb24iLCJpc051bWJlckFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJ2YWwiLCJmbGF0dGVuQnkiLCJhcnIiLCJnZXRDaGlsZHJlbiIsImZsYXQiLCJyZWN1cnNlIiwic3ViQXJyIiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJtZW1vIiwiZ2V0RGVwcyIsImZuIiwib3B0cyIsImRlcHMiLCJyZXN1bHQiLCJkZXBUaW1lIiwiZGVidWciLCJEYXRlIiwibm93IiwibmV3RGVwcyIsImRlcHNDaGFuZ2VkIiwic29tZSIsImRlcCIsImluZGV4IiwicmVzdWx0VGltZSIsIm9uQ2hhbmdlIiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJjcmVhdGVDb2x1bW4iLCJ0YWJsZSIsImNvbHVtbkRlZiIsImRlcHRoIiwicGFyZW50IiwiX3JlZiIsIl9yZXNvbHZlZENvbHVtbkRlZiRpZCIsImRlZmF1bHRDb2x1bW4iLCJfZ2V0RGVmYXVsdENvbHVtbkRlZiIsInJlc29sdmVkQ29sdW1uRGVmIiwiYWNjZXNzb3JLZXkiLCJpZCIsInJlcGxhY2UiLCJ1bmRlZmluZWQiLCJoZWFkZXIiLCJhY2Nlc3NvckZuIiwiaW5jbHVkZXMiLCJvcmlnaW5hbFJvdyIsInNwbGl0IiwiX3Jlc3VsdCIsInByb2Nlc3MiLCJ3YXJuIiwiRXJyb3IiLCJjb2x1bW4iLCJjb2x1bW5zIiwiZ2V0RmxhdENvbHVtbnMiLCJfY29sdW1uJGNvbHVtbnMiLCJmbGF0TWFwIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBIiwib3B0aW9ucyIsImRlYnVnQWxsIiwiZGVidWdDb2x1bW5zIiwiZ2V0TGVhZkNvbHVtbnMiLCJfZ2V0T3JkZXJDb2x1bW5zRm4iLCJvcmRlckNvbHVtbnMiLCJfY29sdW1uJGNvbHVtbnMyIiwibGVhZkNvbHVtbnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIiwiZmVhdHVyZSIsIl9mZWF0dXJlcyIsImNyZWF0ZUhlYWRlciIsIl9vcHRpb25zJGlkIiwiaXNQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVySWQiLCJzdWJIZWFkZXJzIiwiY29sU3BhbiIsInJvd1NwYW4iLCJoZWFkZXJHcm91cCIsImdldExlYWZIZWFkZXJzIiwibGVhZkhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyIiwiaCIsIm1hcCIsImdldENvbnRleHQiLCJIZWFkZXJzIiwiY3JlYXRlVGFibGUiLCJnZXRIZWFkZXJHcm91cHMiLCJnZXRBbGxDb2x1bW5zIiwiZ2V0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0U3RhdGUiLCJjb2x1bW5QaW5uaW5nIiwibGVmdCIsInJpZ2h0IiwiYWxsQ29sdW1ucyIsIl9sZWZ0JG1hcCRmaWx0ZXIiLCJfcmlnaHQkbWFwJGZpbHRlciIsImxlZnRDb2x1bW5zIiwiY29sdW1uSWQiLCJmaW5kIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJpZ2h0Q29sdW1ucyIsImNlbnRlckNvbHVtbnMiLCJoZWFkZXJHcm91cHMiLCJidWlsZEhlYWRlckdyb3VwcyIsImRlYnVnSGVhZGVycyIsImdldENlbnRlckhlYWRlckdyb3VwcyIsImdldExlZnRIZWFkZXJHcm91cHMiLCJfbGVmdCRtYXAkZmlsdGVyMiIsIm9yZGVyZWRMZWFmQ29sdW1ucyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTMiLCJnZXRSaWdodEhlYWRlckdyb3VwcyIsIl9yaWdodCRtYXAkZmlsdGVyMiIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTQiLCJnZXRGb290ZXJHcm91cHMiLCJyZXZlcnNlIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBNSIsImdldExlZnRGb290ZXJHcm91cHMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2IiwiZ2V0Q2VudGVyRm9vdGVyR3JvdXBzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBNyIsImdldFJpZ2h0Rm9vdGVyR3JvdXBzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBOCIsImdldEZsYXRIZWFkZXJzIiwiaGVhZGVycyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTkiLCJnZXRMZWZ0RmxhdEhlYWRlcnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMCIsImdldENlbnRlckZsYXRIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTEiLCJnZXRSaWdodEZsYXRIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTIiLCJnZXRDZW50ZXJMZWFmSGVhZGVycyIsImZsYXRIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTMiLCJnZXRMZWZ0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMyIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTQiLCJnZXRSaWdodExlYWZIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzMyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTE1IiwiY2VudGVyIiwiX2xlZnQkMCRoZWFkZXJzIiwiX2xlZnQkIiwiX2NlbnRlciQwJGhlYWRlcnMiLCJfY2VudGVyJCIsIl9yaWdodCQwJGhlYWRlcnMiLCJfcmlnaHQkIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTYiLCJjb2x1bW5zVG9Hcm91cCIsImhlYWRlckZhbWlseSIsIl9oZWFkZXJHcm91cHMkMCRoZWFkZSIsIl9oZWFkZXJHcm91cHMkIiwibWF4RGVwdGgiLCJmaW5kTWF4RGVwdGgiLCJnZXRJc1Zpc2libGUiLCJjcmVhdGVIZWFkZXJHcm91cCIsImhlYWRlcnNUb0dyb3VwIiwiam9pbiIsInBlbmRpbmdQYXJlbnRIZWFkZXJzIiwiaGVhZGVyVG9Hcm91cCIsImxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIiLCJpc0xlYWZIZWFkZXIiLCJib3R0b21IZWFkZXJzIiwicmVjdXJzZUhlYWRlcnNGb3JTcGFucyIsImZpbHRlcmVkSGVhZGVycyIsImNoaWxkUm93U3BhbnMiLCJjaGlsZENvbFNwYW4iLCJjaGlsZFJvd1NwYW4iLCJtaW5DaGlsZFJvd1NwYW4iLCJkZWZhdWx0Q29sdW1uU2l6aW5nIiwic2l6ZSIsIm1pblNpemUiLCJtYXhTaXplIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUiLCJzdGFydE9mZnNldCIsInN0YXJ0U2l6ZSIsImRlbHRhT2Zmc2V0IiwiZGVsdGFQZXJjZW50YWdlIiwiaXNSZXNpemluZ0NvbHVtbiIsImNvbHVtblNpemluZ1N0YXJ0IiwiQ29sdW1uU2l6aW5nIiwiZ2V0RGVmYXVsdENvbHVtbkRlZiIsImdldEluaXRpYWxTdGF0ZSIsInN0YXRlIiwiY29sdW1uU2l6aW5nIiwiY29sdW1uU2l6aW5nSW5mbyIsImdldERlZmF1bHRPcHRpb25zIiwiY29sdW1uUmVzaXplTW9kZSIsIm9uQ29sdW1uU2l6aW5nQ2hhbmdlIiwib25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlIiwiZ2V0U2l6ZSIsIl9jb2x1bW4kY29sdW1uRGVmJG1pbiIsIl9jb2x1bW4kY29sdW1uRGVmJG1heCIsImNvbHVtblNpemUiLCJnZXRTdGFydCIsInBvc2l0aW9uIiwiZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyIsImdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZmluZEluZGV4IiwicHJldlNpYmxpbmdDb2x1bW4iLCJyZXNldFNpemUiLCJzZXRDb2x1bW5TaXppbmciLCJfcmVmMiIsIl8iLCJyZXN0IiwiZ2V0Q2FuUmVzaXplIiwiX2NvbHVtbiRjb2x1bW5EZWYkZW5hIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlIiwiZW5hYmxlUmVzaXppbmciLCJlbmFibGVDb2x1bW5SZXNpemluZyIsImdldElzUmVzaXppbmciLCJzdW0iLCJfaGVhZGVyJGNvbHVtbiRnZXRTaXoiLCJwcmV2U2libGluZ0hlYWRlciIsImdldFJlc2l6ZUhhbmRsZXIiLCJnZXRDb2x1bW4iLCJjYW5SZXNpemUiLCJlIiwicGVyc2lzdCIsImlzVG91Y2hTdGFydEV2ZW50IiwidG91Y2hlcyIsImNsaWVudFgiLCJuZXdDb2x1bW5TaXppbmciLCJ1cGRhdGVPZmZzZXQiLCJldmVudFR5cGUiLCJjbGllbnRYUG9zIiwic2V0Q29sdW1uU2l6aW5nSW5mbyIsIl9vbGQkc3RhcnRPZmZzZXQiLCJfb2xkJHN0YXJ0U2l6ZSIsIl9yZWYzIiwiaGVhZGVyU2l6ZSIsIm9uTW92ZSIsIm9uRW5kIiwibW91c2VFdmVudHMiLCJtb3ZlSGFuZGxlciIsInVwSGFuZGxlciIsImRvY3VtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvdWNoRXZlbnRzIiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiX2UkdG91Y2hlcyQiLCJwYXNzaXZlSWZTdXBwb3J0ZWQiLCJwYXNzaXZlRXZlbnRTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc2V0Q29sdW1uU2l6aW5nIiwiZGVmYXVsdFN0YXRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjIiwiaW5pdGlhbFN0YXRlIiwicmVzZXRIZWFkZXJTaXplSW5mbyIsIl90YWJsZSRpbml0aWFsU3RhdGUkYzIiLCJnZXRUb3RhbFNpemUiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAyIiwicmVkdWNlIiwiZ2V0TGVmdFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRyIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRzIiLCJnZXRDZW50ZXJUb3RhbFNpemUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUyIiwiZ2V0UmlnaHRUb3RhbFNpemUiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIyIiwicGFzc2l2ZVN1cHBvcnRlZCIsInN1cHBvcnRlZCIsIndpbmRvdyIsImVyciIsInR5cGUiLCJFeHBhbmRpbmciLCJleHBhbmRlZCIsIm9uRXhwYW5kZWRDaGFuZ2UiLCJwYWdpbmF0ZUV4cGFuZGVkUm93cyIsInJlZ2lzdGVyZWQiLCJxdWV1ZWQiLCJfYXV0b1Jlc2V0RXhwYW5kZWQiLCJfdGFibGUkb3B0aW9ucyRhdXRvUmUiLCJfcXVldWUiLCJhdXRvUmVzZXRBbGwiLCJhdXRvUmVzZXRFeHBhbmRlZCIsIm1hbnVhbEV4cGFuZGluZyIsInJlc2V0RXhwYW5kZWQiLCJzZXRFeHBhbmRlZCIsInRvZ2dsZUFsbFJvd3NFeHBhbmRlZCIsImdldElzQWxsUm93c0V4cGFuZGVkIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSIsImdldENhblNvbWVSb3dzRXhwYW5kIiwiZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsIiwiZmxhdFJvd3MiLCJyb3ciLCJnZXRDYW5FeHBhbmQiLCJnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyIiwiZ2V0SXNTb21lUm93c0V4cGFuZGVkIiwiT2JqZWN0IiwidmFsdWVzIiwia2V5cyIsImdldFJvd01vZGVsIiwiZ2V0SXNFeHBhbmRlZCIsImdldEV4cGFuZGVkRGVwdGgiLCJyb3dJZHMiLCJyb3dzQnlJZCIsInNwbGl0SWQiLCJnZXRQcmVFeHBhbmRlZFJvd01vZGVsIiwiZ2V0U29ydGVkUm93TW9kZWwiLCJnZXRFeHBhbmRlZFJvd01vZGVsIiwiX2dldEV4cGFuZGVkUm93TW9kZWwiLCJjcmVhdGVSb3ciLCJ0b2dnbGVFeHBhbmRlZCIsIl9leHBhbmRlZCIsImV4aXN0cyIsIm9sZEV4cGFuZGVkIiwicm93SWQiLCJfdGFibGUkb3B0aW9ucyRnZXRJc1IiLCJnZXRJc1Jvd0V4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0Um93IiwiX3JvdyRzdWJSb3dzIiwiZ2V0Um93Q2FuRXhwYW5kIiwiZW5hYmxlRXhwYW5kaW5nIiwic3ViUm93cyIsImdldElzQWxsUGFyZW50c0V4cGFuZGVkIiwiaXNGdWxseUV4cGFuZGVkIiwiY3VycmVudFJvdyIsInBhcmVudElkIiwiZ2V0Um93IiwiZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyIiwiY2FuRXhwYW5kIiwiaW5jbHVkZXNTdHJpbmciLCJmaWx0ZXJWYWx1ZSIsIl9yb3ckZ2V0VmFsdWUiLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImdldFZhbHVlIiwidG9TdHJpbmciLCJhdXRvUmVtb3ZlIiwidGVzdEZhbHNleSIsImluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlIiwiX3JvdyRnZXRWYWx1ZTIiLCJlcXVhbHNTdHJpbmciLCJfcm93JGdldFZhbHVlMyIsImFyckluY2x1ZGVzIiwiX3JvdyRnZXRWYWx1ZTQiLCJhcnJJbmNsdWRlc0FsbCIsIl9yb3ckZ2V0VmFsdWU1IiwiYXJySW5jbHVkZXNTb21lIiwiX3JvdyRnZXRWYWx1ZTYiLCJlcXVhbHMiLCJ3ZWFrRXF1YWxzIiwiaW5OdW1iZXJSYW5nZSIsInJvd1ZhbHVlIiwicmVzb2x2ZUZpbHRlclZhbHVlIiwidW5zYWZlTWluIiwidW5zYWZlTWF4IiwicGFyc2VkTWluIiwicGFyc2VGbG9hdCIsInBhcnNlZE1heCIsImlzTmFOIiwiSW5maW5pdHkiLCJ0ZW1wIiwiZmlsdGVyRm5zIiwiRmlsdGVycyIsImZpbHRlckZuIiwiY29sdW1uRmlsdGVycyIsImdsb2JhbEZpbHRlciIsIm9uQ29sdW1uRmlsdGVyc0NoYW5nZSIsIm9uR2xvYmFsRmlsdGVyQ2hhbmdlIiwiZmlsdGVyRnJvbUxlYWZSb3dzIiwibWF4TGVhZlJvd0ZpbHRlckRlcHRoIiwiZ2xvYmFsRmlsdGVyRm4iLCJnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkZ2V0Q29yZVJvd01vZGUiLCJ2YWx1ZSIsImdldENvcmVSb3dNb2RlbCIsIl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQiLCJnZXRBdXRvRmlsdGVyRm4iLCJmaXJzdFJvdyIsImdldEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiIsImdldENhbkZpbHRlciIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTIiLCJlbmFibGVDb2x1bW5GaWx0ZXIiLCJlbmFibGVDb2x1bW5GaWx0ZXJzIiwiZW5hYmxlRmlsdGVycyIsImdldENhbkdsb2JhbEZpbHRlciIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYTIiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUzIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCIsIl90YWJsZSRvcHRpb25zJGdldENvbCIsImVuYWJsZUdsb2JhbEZpbHRlciIsImdldElzRmlsdGVyZWQiLCJnZXRGaWx0ZXJJbmRleCIsImdldEZpbHRlclZhbHVlIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtMiIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTMiLCJzZXRGaWx0ZXJWYWx1ZSIsInNldENvbHVtbkZpbHRlcnMiLCJwcmV2aW91c2ZpbHRlciIsIm5ld0ZpbHRlciIsInNob3VsZEF1dG9SZW1vdmVGaWx0ZXIiLCJfb2xkJGZpbHRlciIsIm5ld0ZpbHRlck9iaiIsIl9vbGQkbWFwIiwiX2dldEZhY2V0ZWRSb3dNb2RlbCIsImdldEZhY2V0ZWRSb3dNb2RlbCIsImdldFByZUZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJNYXAiLCJfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJjb2x1bW5GaWx0ZXJzTWV0YSIsImdldEdsb2JhbEF1dG9GaWx0ZXJGbiIsImdldEdsb2JhbEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMyIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjQiLCJnZXRBbGxMZWFmQ29sdW1ucyIsInVwZGF0ZUZuIiwiX2Z1bmN0aW9uYWxVcGRhdGUiLCJzZXRHbG9iYWxGaWx0ZXIiLCJyZXNldEdsb2JhbEZpbHRlciIsInJlc2V0Q29sdW1uRmlsdGVycyIsImdldEZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmlsdGVyZWRSb3dNb2RlbCIsIm1hbnVhbEZpbHRlcmluZyIsIl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJnZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJfZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJfZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJfbGVhZlJvd3MiLCJjaGlsZFJvd3MiLCJuZXh0IiwibmV4dFZhbHVlIiwiZXh0ZW50IiwibWVhbiIsImxlYWZSb3dzIiwiY291bnQiLCJtZWRpYW4iLCJtaWQiLCJmbG9vciIsIm51bXMiLCJzb3J0IiwiYSIsImIiLCJ1bmlxdWUiLCJmcm9tIiwiU2V0IiwidW5pcXVlQ291bnQiLCJfY29sdW1uSWQiLCJhZ2dyZWdhdGlvbkZucyIsIkdyb3VwaW5nIiwiYWdncmVnYXRlZENlbGwiLCJwcm9wcyIsIl90b1N0cmluZyIsIl9wcm9wcyRnZXRWYWx1ZSIsImFnZ3JlZ2F0aW9uRm4iLCJncm91cGluZyIsIm9uR3JvdXBpbmdDaGFuZ2UiLCJncm91cGVkQ29sdW1uTW9kZSIsInRvZ2dsZUdyb3VwaW5nIiwic2V0R3JvdXBpbmciLCJnZXRDYW5Hcm91cCIsImVuYWJsZUdyb3VwaW5nIiwiZ2V0SXNHcm91cGVkIiwiX3RhYmxlJGdldFN0YXRlJGdyb3VwIiwiZ2V0R3JvdXBlZEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJGdyb3VwMiIsImluZGV4T2YiLCJnZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIiLCJjYW5Hcm91cCIsImdldEF1dG9BZ2dyZWdhdGlvbkZuIiwicHJvdG90eXBlIiwiY2FsbCIsImdldEFnZ3JlZ2F0aW9uRm4iLCJfdGFibGUkb3B0aW9ucyRhZ2dyZWciLCJfdGFibGUkb3B0aW9ucyRhZ2dyZWcyIiwicmVzZXRHcm91cGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkZyIsImdldFByZUdyb3VwZWRSb3dNb2RlbCIsImdldEdyb3VwZWRSb3dNb2RlbCIsIl9nZXRHcm91cGVkUm93TW9kZWwiLCJtYW51YWxHcm91cGluZyIsImdyb3VwaW5nQ29sdW1uSWQiLCJnZXRHcm91cGluZ1ZhbHVlIiwiX2dyb3VwaW5nVmFsdWVzQ2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm9yaWdpbmFsIiwiY3JlYXRlQ2VsbCIsImNlbGwiLCJnZXRJc1BsYWNlaG9sZGVyIiwiZ2V0SXNBZ2dyZWdhdGVkIiwibm9uR3JvdXBpbmdDb2x1bW5zIiwiY29sIiwiZ3JvdXBpbmdDb2x1bW5zIiwiZyIsIk9yZGVyaW5nIiwiY29sdW1uT3JkZXIiLCJvbkNvbHVtbk9yZGVyQ2hhbmdlIiwic2V0Q29sdW1uT3JkZXIiLCJyZXNldENvbHVtbk9yZGVyIiwib3JkZXJlZENvbHVtbnMiLCJjb2x1bW5PcmRlckNvcHkiLCJjb2x1bW5zQ29weSIsInRhcmdldENvbHVtbklkIiwic2hpZnQiLCJmb3VuZEluZGV4Iiwic3BsaWNlIiwiZGVmYXVsdFBhZ2VJbmRleCIsImRlZmF1bHRQYWdlU2l6ZSIsImdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUiLCJwYWdlSW5kZXgiLCJwYWdlU2l6ZSIsIlBhZ2luYXRpb24iLCJwYWdpbmF0aW9uIiwib25QYWdpbmF0aW9uQ2hhbmdlIiwiX2F1dG9SZXNldFBhZ2VJbmRleCIsImF1dG9SZXNldFBhZ2VJbmRleCIsIm1hbnVhbFBhZ2luYXRpb24iLCJyZXNldFBhZ2VJbmRleCIsInNldFBhZ2luYXRpb24iLCJzYWZlVXBkYXRlciIsIm5ld1N0YXRlIiwicmVzZXRQYWdpbmF0aW9uIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwIiwic2V0UGFnZUluZGV4IiwibWF4UGFnZUluZGV4IiwicGFnZUNvdW50IiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiIsInJlc2V0UGFnZVNpemUiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAzIiwiX3RhYmxlJGluaXRpYWxTdGF0ZTIiLCJzZXRQYWdlU2l6ZSIsInRvcFJvd0luZGV4Iiwic2V0UGFnZUNvdW50IiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvIiwibmV3UGFnZUNvdW50IiwiZ2V0UGFnZU9wdGlvbnMiLCJnZXRQYWdlQ291bnQiLCJwYWdlT3B0aW9ucyIsImZpbGwiLCJpIiwiZGVidWdUYWJsZSIsImdldENhblByZXZpb3VzUGFnZSIsImdldENhbk5leHRQYWdlIiwicHJldmlvdXNQYWdlIiwibmV4dFBhZ2UiLCJnZXRQYWdpbmF0aW9uUm93TW9kZWwiLCJfZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiIsImNlaWwiLCJyb3dzIiwiZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSIsImdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUiLCJ0b3AiLCJib3R0b20iLCJQaW5uaW5nIiwicm93UGlubmluZyIsIm9uQ29sdW1uUGlubmluZ0NoYW5nZSIsIm9uUm93UGlubmluZ0NoYW5nZSIsInBpbiIsImNvbHVtbklkcyIsInNldENvbHVtblBpbm5pbmciLCJfb2xkJGxlZnQzIiwiX29sZCRyaWdodDMiLCJfb2xkJGxlZnQiLCJfb2xkJHJpZ2h0IiwiX29sZCRsZWZ0MiIsIl9vbGQkcmlnaHQyIiwiZ2V0Q2FuUGluIiwiX2QkY29sdW1uRGVmJGVuYWJsZVBpIiwiZW5hYmxlUGlubmluZyIsImVuYWJsZUNvbHVtblBpbm5pbmciLCJnZXRJc1Bpbm5lZCIsImxlYWZDb2x1bW5JZHMiLCJpc0xlZnQiLCJpc1JpZ2h0IiwiZ2V0UGlubmVkSW5kZXgiLCJpbmNsdWRlTGVhZlJvd3MiLCJpbmNsdWRlUGFyZW50Um93cyIsImxlYWZSb3dJZHMiLCJnZXRMZWFmUm93cyIsInBhcmVudFJvd0lkcyIsImdldFBhcmVudFJvd3MiLCJzZXRSb3dQaW5uaW5nIiwiX29sZCR0b3AzIiwiX29sZCRib3R0b20zIiwiX29sZCR0b3AiLCJfb2xkJGJvdHRvbSIsImhhcyIsIl9vbGQkdG9wMiIsIl9vbGQkYm90dG9tMiIsIl9yZWY0IiwiZW5hYmxlUm93UGlubmluZyIsImlzVG9wIiwiaXNCb3R0b20iLCJfdGFibGUkX2dldFBpbm5lZFJvd3MiLCJfdmlzaWJsZVBpbm5lZFJvd0lkcyQiLCJ2aXNpYmxlUGlubmVkUm93SWRzIiwiX2dldFBpbm5lZFJvd3MiLCJfcmVmNSIsImdldENlbnRlclZpc2libGVDZWxscyIsIl9nZXRBbGxWaXNpYmxlQ2VsbHMiLCJhbGxDZWxscyIsImxlZnRBbmRSaWdodCIsImRlYnVnUm93cyIsImdldExlZnRWaXNpYmxlQ2VsbHMiLCJjZWxscyIsImdldFJpZ2h0VmlzaWJsZUNlbGxzIiwicmVzZXRDb2x1bW5QaW5uaW5nIiwiZ2V0SXNTb21lQ29sdW1uc1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkcG9zaXRpbyIsInBpbm5pbmdTdGF0ZSIsIl9waW5uaW5nU3RhdGUkbGVmdCIsIl9waW5uaW5nU3RhdGUkcmlnaHQiLCJnZXRMZWZ0TGVhZkNvbHVtbnMiLCJnZXRSaWdodExlYWZDb2x1bW5zIiwiZ2V0Q2VudGVyTGVhZkNvbHVtbnMiLCJyZXNldFJvd1Bpbm5pbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHIiLCJnZXRJc1NvbWVSb3dzUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvMiIsIl9waW5uaW5nU3RhdGUkdG9wIiwiX3Bpbm5pbmdTdGF0ZSRib3R0b20iLCJ2aXNpYmxlUm93cyIsInBpbm5lZFJvd0lkcyIsIl90YWJsZSRvcHRpb25zJGtlZXBQaSIsImtlZXBQaW5uZWRSb3dzIiwiZ2V0VG9wUm93cyIsImdldEJvdHRvbVJvd3MiLCJnZXRDZW50ZXJSb3dzIiwiYWxsUm93cyIsInRvcEFuZEJvdHRvbSIsIlJvd1NlbGVjdGlvbiIsInJvd1NlbGVjdGlvbiIsIm9uUm93U2VsZWN0aW9uQ2hhbmdlIiwiZW5hYmxlUm93U2VsZWN0aW9uIiwiZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24iLCJlbmFibGVTdWJSb3dTZWxlY3Rpb24iLCJzZXRSb3dTZWxlY3Rpb24iLCJyZXNldFJvd1NlbGVjdGlvbiIsInRvZ2dsZUFsbFJvd3NTZWxlY3RlZCIsImdldElzQWxsUm93c1NlbGVjdGVkIiwicHJlR3JvdXBlZEZsYXRSb3dzIiwiZ2V0Q2FuU2VsZWN0IiwidG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCIsInJlc29sdmVkVmFsdWUiLCJnZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJtdXRhdGVSb3dJc1NlbGVjdGVkIiwiZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCIsImdldFNlbGVjdGVkUm93TW9kZWwiLCJyb3dNb2RlbCIsInNlbGVjdFJvd3NGbiIsImdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCIsImdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsIiwiaXNBbGxSb3dzU2VsZWN0ZWQiLCJwYWdpbmF0aW9uRmxhdFJvd3MiLCJpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NvbWVSb3dzU2VsZWN0ZWQiLCJfdGFibGUkZ2V0U3RhdGUkcm93U2UiLCJ0b3RhbFNlbGVjdGVkIiwiZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU2VsZWN0ZWQiLCJnZXRJc1NvbWVTZWxlY3RlZCIsImdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXIiLCJ0b2dnbGVTZWxlY3RlZCIsImlzU2VsZWN0ZWQiLCJfb3B0cyRzZWxlY3RDaGlsZHJlbiIsInNlbGVjdGVkUm93SWRzIiwic2VsZWN0Q2hpbGRyZW4iLCJpc1Jvd1NlbGVjdGVkIiwiaXNTdWJSb3dTZWxlY3RlZCIsImdldElzQWxsU3ViUm93c1NlbGVjdGVkIiwiZ2V0Q2FuU2VsZWN0U3ViUm93cyIsImdldENhbk11bHRpU2VsZWN0IiwiZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyIiwiY2FuU2VsZWN0IiwiX3RhcmdldCIsImluY2x1ZGVDaGlsZHJlbiIsIm5ld1NlbGVjdGVkRmxhdFJvd3MiLCJuZXdTZWxlY3RlZFJvd3NCeUlkIiwicmVjdXJzZVJvd3MiLCJfcm93JHN1YlJvd3MyIiwic2VsZWN0aW9uIiwiX3NlbGVjdGlvbiRyb3ckaWQiLCJfcm93JHN1YlJvd3MzIiwiYWxsQ2hpbGRyZW5TZWxlY3RlZCIsInNvbWVTZWxlY3RlZCIsInN1YlJvdyIsInN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQiLCJyZVNwbGl0QWxwaGFOdW1lcmljIiwiYWxwaGFudW1lcmljIiwicm93QSIsInJvd0IiLCJjb21wYXJlQWxwaGFudW1lcmljIiwiYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSIsInRleHQiLCJjb21wYXJlQmFzaWMiLCJ0ZXh0Q2FzZVNlbnNpdGl2ZSIsImRhdGV0aW1lIiwiYmFzaWMiLCJhU3RyIiwiYlN0ciIsImFhIiwiYmIiLCJhbiIsInBhcnNlSW50IiwiYm4iLCJjb21ibyIsInNvcnRpbmdGbnMiLCJTb3J0aW5nIiwic29ydGluZyIsInNvcnRpbmdGbiIsInNvcnRVbmRlZmluZWQiLCJvblNvcnRpbmdDaGFuZ2UiLCJpc011bHRpU29ydEV2ZW50Iiwic2hpZnRLZXkiLCJnZXRBdXRvU29ydGluZ0ZuIiwiZmlyc3RSb3dzIiwic2xpY2UiLCJpc1N0cmluZyIsImdldEF1dG9Tb3J0RGlyIiwiZ2V0U29ydGluZ0ZuIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluMiIsInRvZ2dsZVNvcnRpbmciLCJkZXNjIiwibXVsdGkiLCJuZXh0U29ydGluZ09yZGVyIiwiZ2V0TmV4dFNvcnRpbmdPcmRlciIsImhhc01hbnVhbFZhbHVlIiwic2V0U29ydGluZyIsImV4aXN0aW5nU29ydGluZyIsImV4aXN0aW5nSW5kZXgiLCJuZXdTb3J0aW5nIiwic29ydEFjdGlvbiIsIm5leHREZXNjIiwiZ2V0Q2FuTXVsdGlTb3J0IiwiX3RhYmxlJG9wdGlvbnMkbWF4TXVsIiwibWF4TXVsdGlTb3J0Q29sQ291bnQiLCJnZXRGaXJzdFNvcnREaXIiLCJfY29sdW1uJGNvbHVtbkRlZiRzb3IiLCJzb3J0RGVzY0ZpcnN0IiwiZmlyc3RTb3J0RGlyZWN0aW9uIiwiaXNTb3J0ZWQiLCJnZXRJc1NvcnRlZCIsImVuYWJsZVNvcnRpbmdSZW1vdmFsIiwiZW5hYmxlTXVsdGlSZW1vdmUiLCJnZXRDYW5Tb3J0IiwiZW5hYmxlU29ydGluZyIsImVuYWJsZU11bHRpU29ydCIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aSIsImNvbHVtblNvcnQiLCJnZXRTb3J0SW5kZXgiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkyIiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMyIsImNsZWFyU29ydGluZyIsImdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyIiwiY2FuU29ydCIsInJlc2V0U29ydGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkcyIsImdldFByZVNvcnRlZFJvd01vZGVsIiwiX2dldFNvcnRlZFJvd01vZGVsIiwibWFudWFsU29ydGluZyIsIlZpc2liaWxpdHkiLCJjb2x1bW5WaXNpYmlsaXR5Iiwib25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlIiwidG9nZ2xlVmlzaWJpbGl0eSIsImdldENhbkhpZGUiLCJzZXRDb2x1bW5WaXNpYmlsaXR5IiwiZW5hYmxlSGlkaW5nIiwiZ2V0VG9nZ2xlVmlzaWJpbGl0eUhhbmRsZXIiLCJnZXRBbGxDZWxscyIsImdldFZpc2libGVDZWxscyIsIm1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCIsImdldENvbHVtbnMiLCJnZXRWaXNpYmxlRmxhdENvbHVtbnMiLCJnZXRBbGxGbGF0Q29sdW1ucyIsImdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyIsInJlc2V0Q29sdW1uVmlzaWJpbGl0eSIsInRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlIiwiX3ZhbHVlIiwiZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSIsIm9iaiIsImdldElzU29tZUNvbHVtbnNWaXNpYmxlIiwiZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyIiwiZmVhdHVyZXMiLCJfb3B0aW9ucyRpbml0aWFsU3RhdGUiLCJkZWZhdWx0T3B0aW9ucyIsImFzc2lnbiIsIm1lcmdlT3B0aW9ucyIsImNvcmVJbml0aWFsU3RhdGUiLCJfZmVhdHVyZSRnZXRJbml0aWFsU3QiLCJxdWV1ZWRUaW1lb3V0IiwiY29yZUluc3RhbmNlIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjYXRjaCIsImVycm9yIiwic2V0VGltZW91dCIsInJlc2V0Iiwic2V0T3B0aW9ucyIsIm5ld09wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX2dldFJvd0lkIiwiZ2V0Um93SWQiLCJfZ2V0Q29yZVJvd01vZGVsIiwic2VhcmNoQWxsIiwiX2RlZmF1bHRDb2x1bW4iLCJfcHJvcHMkcmVuZGVyVmFsdWUkdG8iLCJfcHJvcHMkcmVuZGVyVmFsdWUiLCJyZW5kZXJWYWx1ZSIsIl9nZXRDb2x1bW5EZWZzIiwiY29sdW1uRGVmcyIsInJlY3Vyc2VDb2x1bW5zIiwiZ3JvdXBpbmdDb2x1bW5EZWYiLCJfZ2V0QWxsRmxhdENvbHVtbnNCeUlkIiwiZmxhdENvbHVtbnMiLCJhY2MiLCJnZXRSZW5kZXJWYWx1ZSIsIl9jZWxsJGdldFZhbHVlIiwicmVuZGVyRmFsbGJhY2tWYWx1ZSIsInJvd0luZGV4IiwiX3ZhbHVlc0NhY2hlIiwiX3VuaXF1ZVZhbHVlc0NhY2hlIiwiZ2V0VW5pcXVlVmFsdWVzIiwiZ2V0UGFyZW50Um93IiwicGFyZW50Um93cyIsInBhcmVudFJvdyIsImNyZWF0ZUNvbHVtbkhlbHBlciIsImFjY2Vzc29yIiwiZGlzcGxheSIsImdyb3VwIiwiZGF0YSIsImFjY2Vzc1Jvd3MiLCJvcmlnaW5hbFJvd3MiLCJnZXRTdWJSb3dzIiwiX3JvdyRvcmlnaW5hbFN1YlJvd3MiLCJvcmlnaW5hbFN1YlJvd3MiLCJmaWx0ZXJSb3dzIiwiZmlsdGVyUm93SW1wbCIsImZpbHRlclJvd01vZGVsRnJvbUxlYWZzIiwiZmlsdGVyUm93TW9kZWxGcm9tUm9vdCIsInJvd3NUb0ZpbHRlciIsImZpbHRlclJvdyIsIl90YWJsZSRvcHRpb25zJG1heExlYSIsIm5ld0ZpbHRlcmVkRmxhdFJvd3MiLCJuZXdGaWx0ZXJlZFJvd3NCeUlkIiwicmVjdXJzZUZpbHRlclJvd3MiLCJuZXdSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEyIiwicGFzcyIsInJlc29sdmVkQ29sdW1uRmlsdGVycyIsInJlc29sdmVkR2xvYmFsRmlsdGVycyIsIl9maWx0ZXJGbiRyZXNvbHZlRmlsdCIsImZpbHRlcmFibGVJZHMiLCJnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zIiwiX2dsb2JhbEZpbHRlckZuJHJlc29sIiwiY3VycmVudENvbHVtbkZpbHRlciIsImN1cnJlbnRHbG9iYWxGaWx0ZXIiLCJqIiwiZmlsdGVyTWV0YSIsIl9fZ2xvYmFsX18iLCJmaWx0ZXJSb3dzSW1wbCIsInByZVJvd01vZGVsIiwiX3RhYmxlJGdldENvbHVtbiIsImZhY2V0ZWRSb3dNb2RlbCIsImZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJfZmFjZXRlZFVuaXF1ZVZhbHVlcyQiLCJzZXQiLCJnZXQiLCJfZmFjZXRlZFJvd01vZGVsJGZsYXQiLCJmaXJzdFZhbHVlIiwiZmFjZXRlZE1pbk1heFZhbHVlcyIsInNvcnRpbmdTdGF0ZSIsInNvcnRlZEZsYXRSb3dzIiwiYXZhaWxhYmxlU29ydGluZyIsImNvbHVtbkluZm9CeUlkIiwic29ydEVudHJ5IiwiaW52ZXJ0U29ydGluZyIsInNvcnREYXRhIiwic29ydGVkRGF0YSIsIl9zb3J0RW50cnkkZGVzYyIsImNvbHVtbkluZm8iLCJpc0Rlc2MiLCJzb3J0SW50IiwiYVZhbHVlIiwiYlZhbHVlIiwiYVVuZGVmaW5lZCIsImJVbmRlZmluZWQiLCJleGlzdGluZ0dyb3VwaW5nIiwiZ3JvdXBlZEZsYXRSb3dzIiwiZ3JvdXBlZFJvd3NCeUlkIiwiZ3JvdXBVcFJlY3Vyc2l2ZWx5Iiwicm93R3JvdXBzTWFwIiwiZ3JvdXBCeSIsImFnZ3JlZ2F0ZWRHcm91cGVkUm93cyIsImVudHJpZXMiLCJncm91cGluZ1ZhbHVlIiwiZ3JvdXBlZFJvd3MiLCJfZ3JvdXBlZFJvd3MkMCRnZXRWYWwiLCJhZ2dyZWdhdGVGbiIsImdyb3VwTWFwIiwicmVzS2V5IiwicHJldmlvdXMiLCJleHBhbmRSb3dzIiwiZXhwYW5kZWRSb3dzIiwiaGFuZGxlUm93IiwicGFnZVN0YXJ0IiwicGFnZUVuZCIsInBhZ2luYXRlZFJvd01vZGVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;